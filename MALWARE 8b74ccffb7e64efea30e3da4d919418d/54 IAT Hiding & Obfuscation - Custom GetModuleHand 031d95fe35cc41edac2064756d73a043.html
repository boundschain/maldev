<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>54. IAT Hiding &amp; Obfuscation - Custom GetModuleHandle</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="031d95fe-35cc-41ed-ac20-64756d73a043" class="page sans"><header><h1 class="page-title"><a href="https://maldevacademy.com/modules/54"><strong>54. IAT Hiding &amp; Obfuscation - Custom GetModuleHandle</strong></a></h1></header><div class="page-body"><h2 id="1310fea2-ccf7-48e2-bb3f-2bc662f88909" class=""><strong>IAT Hiding &amp; Obfuscation - Custom GetModuleHandle</strong></h2><h3 id="54462498-1e57-4cc6-ba50-8633071020a9" class=""><strong>Introduction</strong></h3><p id="4ac1f91f-4494-447a-a170-b21693d8eb52" class="">The <code>GetModuleHandle</code> function retrieves a handle for a specified DLL. The function returns a handle to the DLL or <code>NULL</code> if the DLL does not exist in the calling process.</p><p id="636b58c8-8685-4bd7-b20d-2e9319f3a9db" class="">In this module, a function that will replace <code>GetModuleHandle</code> will be implemented. The new function&#x27;s prototype is shown below.</p><pre id="0f02cf15-fea9-47d0-92de-f2ede78cf8eb" class="code code-wrap"><code>HMODULE GetModuleHandleReplacement(IN LPCWSTR szModuleName){}
</code></pre><h3 id="224efff9-8f5c-4968-9168-4dc0a56be461" class=""><strong>How GetModuleHandle Works</strong></h3><p id="febb7948-81b8-4f26-a447-5892c3f3dfb1" class="">The <code>HMODULE</code> data type is the base address of the loaded DLL which is where the DLL is located in the address space of the process. Therefore, the goal of the replacement function is to retrieve the base address of a specified DLL.</p><p id="70643753-6fcb-4e3d-a792-2e5a0bba94a7" class="">The Process Environment Block (PEB) contains information regarding the loaded DLLs, notably the <code>PEB_LDR_DATA Ldr</code> member of the PEB structure. Thus, the initial step is to access this member through the PEB structure.</p><h3 id="84f937aa-2b09-463c-868f-6a863dc9b794" class=""><strong>PEB In 64-bit Systems</strong></h3><p id="b077ea6e-c0b4-48b0-9cad-c09025136c2a" class="">Recall that a pointer to the PEB structure is found within the Thread Environment Block (TEB) structure.</p><figure id="8fc697cc-1a1e-4ecc-9c48-e468dc1f2d41" class="image"><a href="54%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetModuleHand%20031d95fe35cc41edac2064756d73a043/custom-getmodulehandle-110036660-4488defa-47aa-4993-902d-0c97cb1673c0.png"><img style="width:1085px" src="54%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetModuleHand%20031d95fe35cc41edac2064756d73a043/custom-getmodulehandle-110036660-4488defa-47aa-4993-902d-0c97cb1673c0.png"/></a></figure><p id="c578b3a3-35b2-4a3c-8cd5-495b6c02305a" class="">In 64-bit systems, an offset to the pointer of the TEB structure is stored in the <em>GS</em> register. The following image is from x64dbg.</p><figure id="c88dda32-c544-46a3-99b5-c63f525e592a" class="image"><a href="54%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetModuleHand%20031d95fe35cc41edac2064756d73a043/custom-getmodulehandle-210036220-10ef0096-9099-4066-b6a6-5c5f06cbb4df.png"><img style="width:1378px" src="54%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetModuleHand%20031d95fe35cc41edac2064756d73a043/custom-getmodulehandle-210036220-10ef0096-9099-4066-b6a6-5c5f06cbb4df.png"/></a></figure><h3 id="f3979b08-3ddd-4c53-9878-d1ed759a632a" class=""><strong>Method 1: Retrieving The PEB In 64-Bit Systems</strong></h3><p id="5f250292-f5b2-401f-9833-7cb12ce3bb77" class="">There are two different approaches to retrieving the PEB. The first method involves retrieving the TEB structure and then getting a pointer to the PEB. This approach can be performed using the <a href="https://learn.microsoft.com/en-us/cpp/intrinsics/readgsbyte-readgsdword-readgsqword-readgsword?view=msvc-170">__readgsqword(0x30)</a> macro in Visual Studio which reads <code>0x30</code> bytes from the GS register to reach a pointer to the TEB structure.</p><pre id="bb3b639f-cb1f-4c7a-903c-3d2e31f23e55" class="code code-wrap"><code>// Method 1
PTEB pTeb = (PTEB)__readgsqword(0x30);
PPEB pPeb = (PPEB)pTeb-&gt;ProcessEnvironmentBlock;
</code></pre><h3 id="d1f377fe-1d28-442e-80e2-8d5225999a57" class=""><strong>Method 2: Retrieving The PEB In 64-Bit Systems</strong></h3><p id="22a0a154-2e81-4ba5-a307-b0c053e1500f" class="">The next method retrieves the PEB structure directly by skipping the TEB structure using <a href="https://learn.microsoft.com/en-us/cpp/intrinsics/readgsbyte-readgsdword-readgsqword-readgsword?view=msvc-170">__readgsqword(0x60)</a> macro in Visual Studio which reads <code>0x60</code> bytes from GS register.</p><pre id="2fb1375a-9d33-44d4-9453-0f805fd6054c" class="code code-wrap"><code>// Method 2
PPEB pPeb2 = (PPEB)(__readgsqword(0x60));
</code></pre><p id="6f47bf3b-0098-4f27-ba9c-573e12ac61e0" class="">This can be done because the <code>ProcessEnvironmentBlock</code> element is <code>0x60</code> (hex) or 96 bytes from the start of the TEB structure</p><figure id="42e9bc2f-5df8-4ac8-9fb4-e0df97f5a423" class="image"><a href="54%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetModuleHand%20031d95fe35cc41edac2064756d73a043/custom-getmodulehandle-021764060-4bc54cbd-29ea-470a-9402-ac2fbd0bb4db.png"><img style="width:791px" src="54%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetModuleHand%20031d95fe35cc41edac2064756d73a043/custom-getmodulehandle-021764060-4bc54cbd-29ea-470a-9402-ac2fbd0bb4db.png"/></a></figure><h3 id="f6207a06-34e6-4c7a-9feb-4028c488a8c5" class=""><strong>PEB In 32-bit Systems</strong></h3><p id="1bd72bae-91a1-434b-94d0-5cd66a069e7e" class="">In 32-bit systems, an offset to the pointer of the TEB structure is stored in the <code>FS</code> register. The following image is from x32dbg.</p><figure id="5ebf5da6-8a6b-4987-a5bb-4692a15bbe45" class="image"><a href="54%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetModuleHand%20031d95fe35cc41edac2064756d73a043/custom-getmodulehandle-310037888-cfab12a2-d9ff-4174-9c6e-2cc335d6809e.png"><img style="width:1322px" src="54%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetModuleHand%20031d95fe35cc41edac2064756d73a043/custom-getmodulehandle-310037888-cfab12a2-d9ff-4174-9c6e-2cc335d6809e.png"/></a></figure><p id="aa5cbbaf-de8a-4881-9a41-87afbd688956" class="">And recall that a <strong>pointer</strong> of the PEB structure is in the TEB.</p><figure id="d30fa053-c220-4cb6-9800-a25b82c523a2" class="image"><a href="54%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetModuleHand%20031d95fe35cc41edac2064756d73a043/custom-getmodulehandle-410036660-4488defa-47aa-4993-902d-0c97cb1673c0.png"><img style="width:1085px" src="54%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetModuleHand%20031d95fe35cc41edac2064756d73a043/custom-getmodulehandle-410036660-4488defa-47aa-4993-902d-0c97cb1673c0.png"/></a></figure><h3 id="c1f0156c-7c98-4802-8da0-8874d444520f" class=""><strong>Method 1: Retrieving The PEB In 32-Bit Systems</strong></h3><p id="759e2ee6-cf3d-43d7-a59e-9cfab8c3b80e" class="">Similarly to 64-bit systems, there are two methods to retrieve the PEB.</p><p id="10a65953-d9a6-4014-8e65-42b44455b1c0" class="">The first method involves getting the TEB structure and then getting the PEB structure using the <a href="https://learn.microsoft.com/en-us/cpp/intrinsics/readfsbyte-readfsdword-readfsqword-readfsword?view=msvc-170">__readfsdword(0x18)</a> macro in Visual Studio which reads <code>0x18</code> bytes from the FS register.</p><pre id="9588bbe1-468e-440c-aaa2-0340ce479c30" class="code code-wrap"><code>// Method 1
PTEB pTeb = (PTEB)__readfsdword(0x18);
PPEB pPeb = (PPEB)pTeb-&gt;ProcessEnvironmentBlock;
</code></pre><h3 id="df905096-4a3f-46e3-b0e5-d93a159fe1d9" class=""><strong>Method 2: Retrieving The PEB In 32-Bit Systems</strong></h3><p id="6dc529c4-d385-4412-9426-a5493ce5fa58" class="">The second method gets the PEB directly by skipping the TEB structure using the <a href="https://learn.microsoft.com/en-us/cpp/intrinsics/readfsbyte-readfsdword-readfsqword-readfsword?view=msvc-170">__readfsdword(0x30)</a> macro in Visual Studio which reads <code>0x30</code> bytes from the FS register.</p><pre id="9ccf3013-1fc7-4875-a6f7-0f60b6d62bfb" class="code code-wrap"><code>// Method 2
PPEB pPeb2 = (PPEB)(__readfsdword(0x30));
</code></pre><p id="56dfa2ce-fb9a-40da-a516-c7c3ddb480b5" class=""><code>0x30</code> (hex) is 48 bytes which is the offset of the <code>ProcessEnvironmentBlock</code> element from the 32-bit TEB structure. The <code>PVOID</code> data type is 4 bytes in 32-bit systems.</p><h3 id="25dcd577-cd31-4559-812d-079aac4a3ead" class=""><strong>Enumerating DLLs</strong></h3><p id="145028a5-f1a1-40d2-b837-84cb929d2465" class="">Once the PEB structure has been retrieved, the next step is to access the <code>PEB_LDR_DATA Ldr</code> member. Recall that this member contains information regarding the loaded DLLs in the process.</p><h3 id="11c819c0-0ba7-4408-ae30-84c82f95c05f" class=""><strong>PEB_LDR_DATA Structure</strong></h3><p id="06cffca5-8534-4177-9065-3ec8c7300446" class="">The <code>PEB_LDR_DATA</code> structure is shown below. The important member in this structure is <code>LIST_ENTRY InMemoryOrderModuleList</code>.</p><pre id="43c32ac0-ea0c-48dc-b0fb-e931a625e766" class="code code-wrap"><code>typedef struct _PEB_LDR_DATA {
  BYTE       Reserved1[8];
  PVOID      Reserved2[3];
  LIST_ENTRY InMemoryOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;
</code></pre><h3 id="e3fc7cc0-c671-4548-8da0-4623b5354849" class=""><strong>LIST_ENTRY Structure</strong></h3><p id="b0f07b3e-6790-4446-81ec-b56127540d67" class="">The <code>LIST_ENTRY</code> structure shown below is a <a href="https://en.wikipedia.org/wiki/Doubly_linked_list">doubly-linked list</a>, which is essentially the same as arrays but easier to access adjacent elements.</p><pre id="61b4b52f-edae-48ac-825c-c489116cc2a9" class="code code-wrap"><code>typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;
</code></pre><p id="f3ec78c4-0075-4ef3-8711-ef84f9b7ef0d" class="">Doubly-linked lists use the <code>Flink</code> and <code>Blink</code> elements as the head and tail pointers, respectively. This means <code>Flink</code> points to the next node in the list whereas the <code>Blink</code> element points to the previous node in the list. These pointers are used to traverse the linked list in both directions. Knowing this, to start enumerating this list, one should start by accessing its first element, <code>InMemoryOrderModuleList.Flink</code>.</p><p id="b5ff8d6b-eee0-41a4-b939-2be6f4caa3d9" class="">According to Microsoft&#x27;s definition for the <code>InMemoryOrderModuleList</code> member, it states that each item in the list is a pointer to an <code>LDR_DATA_TABLE_ENTRY</code> structure.</p><figure id="cfc38200-77bb-40ae-9661-ca0851f42e74" class="image"><a href="54%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetModuleHand%20031d95fe35cc41edac2064756d73a043/msdn-593029583.png"><img style="width:930px" src="54%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetModuleHand%20031d95fe35cc41edac2064756d73a043/msdn-593029583.png"/></a></figure><h3 id="3d67d971-7ca0-4efb-ba73-bfeeca1d7a22" class=""><strong>LDR_DATA_TABLE_ENTRY Structure</strong></h3><p id="c43c729c-31df-44c7-86cb-75be98e2977c" class="">The <code>LDR_DATA_TABLE_ENTRY</code> structure represents a DLL inside the linked list of loaded DLLs for the process. Every <code>LDR_DATA_TABLE_ENTRY</code> represents a unique DLL.</p><pre id="56c9f530-d8fe-43aa-9b63-88301e91f44a" class="code code-wrap"><code>typedef struct _LDR_DATA_TABLE_ENTRY {
    PVOID Reserved1[2];
    LIST_ENTRY InMemoryOrderLinks;	// doubly-linked list that contains the in-memory order of loaded modules
    PVOID Reserved2[2];
    PVOID DllBase;
    PVOID EntryPoint;
    PVOID Reserved3;
    UNICODE_STRING FullDllName;		// &#x27;UNICODE_STRING&#x27; structure that contains the filename of the loaded module
    BYTE Reserved4[8];
    PVOID Reserved5[3];
    union {
        ULONG CheckSum;
        PVOID Reserved6;
    };
    ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;
</code></pre><h3 id="8980b9b7-2f9d-4895-b342-6bc67281fa4e" class=""><strong>Implementation Logic</strong></h3><p id="a1ccbe90-f57b-4cae-bb76-1488a10fe899" class="">Based on everything mentioned so far, the required actions are:</p><ol type="1" id="d9c8beab-7319-4dd1-8838-efff97c5df7f" class="numbered-list" start="1"><li>Retrieve the PEB</li></ol><ol type="1" id="5d3c4a1c-4725-41e1-ba93-6d7519327389" class="numbered-list" start="2"><li>Retrieve the Ldr member from the PEB</li></ol><ol type="1" id="81489d80-f1db-4f18-b41b-920776e40835" class="numbered-list" start="3"><li>Retrieve the first element in the linked list</li></ol><pre id="6040934b-9b6e-4a3e-b0df-4225ae575d06" class="code code-wrap"><code>HMODULE GetModuleHandleReplacement(IN LPCWSTR szModuleName) {

// Getting peb
#ifdef _WIN64 // if compiling as x64
	PPEB			pPeb	= (PEB*)(__readgsqword(0x60));
#elif _WIN32 // if compiling as x32
	PPEB			pPeb	= (PEB*)(__readfsdword(0x30));
#endif// Getting the Ldr
	PPEB_LDR_DATA		    pLdr	= (PPEB_LDR_DATA)(pPeb-&gt;Ldr);

	// Getting the first element in the linked list which contains information about the first module
	PLDR_DATA_TABLE_ENTRY	pDte	= (PLDR_DATA_TABLE_ENTRY)(pLdr-&gt;InMemoryOrderModuleList.Flink);

}
</code></pre><p id="8597a0d2-56b1-4621-a297-5e673e64d84f" class="">Since every <code>pDte</code> represents a unique DLL inside of the linked list, it&#x27;s possible to get to the next element using the following line of code:</p><pre id="c132238d-c65a-46a9-896a-03f57c9a9f3e" class="code code-wrap"><code>pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);
</code></pre><p id="3db4a86a-6737-4ecf-96b8-f50f6f7baade" class="">The above line of code may look complex but all it is doing is dereferencing the value stored at the address pointed to by <code>pDte</code> and then casting the result to a pointer to the <code>PLDR_DATA_TABLE_ENTRY</code> structure. This is simply how linked lists work, which is something like the following image</p><figure id="fd4587c2-da82-46f6-a701-3ae79401e2a6" class="image"><a href="54%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetModuleHand%20031d95fe35cc41edac2064756d73a043/custom-getmodule-new-221769848-48118974-d4b7-4a63-b2ce-8802bdec4573.png"><img style="width:1078px" src="54%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetModuleHand%20031d95fe35cc41edac2064756d73a043/custom-getmodule-new-221769848-48118974-d4b7-4a63-b2ce-8802bdec4573.png"/></a></figure><h3 id="f8d306b9-0a50-435a-9486-90923e15c383" class=""><strong>Enumerate DLLs - Code</strong></h3><p id="9208ae73-ed48-4dd1-b703-fffc4e21bcf7" class="">The code snippet below will retrieve the name of the DLLs already loaded inside the calling process. The function searches for the target module, <code>szModuleName</code>. If there is a match, the function returns a handle to the DLL (<code>HMODULE</code>), otherwise, it returns <code>NULL</code>.</p><pre id="29d0ef3a-a4f5-4cfb-9cc3-88ba135332d3" class="code code-wrap"><code>HMODULE GetModuleHandleReplacement(IN LPCWSTR szModuleName) {

// Getting PEB
#ifdef _WIN64 // if compiling as x64
	PPEB			pPeb	= (PEB*)(__readgsqword(0x60));
#elif _WIN32 // if compiling as x32
	PPEB			pPeb	= (PEB*)(__readfsdword(0x30));
#endif// Getting Ldr
	PPEB_LDR_DATA		    pLdr	= (PPEB_LDR_DATA)(pPeb-&gt;Ldr);

	// Getting the first element in the linked list which contains information about the first module
	PLDR_DATA_TABLE_ENTRY	pDte	= (PLDR_DATA_TABLE_ENTRY)(pLdr-&gt;InMemoryOrderModuleList.Flink);

	while (pDte) {

		// If not null
		if (pDte-&gt;FullDllName.Length != NULL) {
           	// Print the DLL name
			wprintf(L&quot;[i] \&quot;%s\&quot; \n&quot;, pDte-&gt;FullDllName.Buffer);
		}
		else {
			break;
		}

		// Next element in the linked list
		pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);

	}

	return NULL;
}
</code></pre><figure id="4c87c13c-2b28-4ffe-9961-2f972a62b5e4" class="image"><a href="54%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetModuleHand%20031d95fe35cc41edac2064756d73a043/custom-getmodulehandle-510041809-92e59481-49dc-4f6c-bc6d-74133ba5fa3b.png"><img style="width:1363px" src="54%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetModuleHand%20031d95fe35cc41edac2064756d73a043/custom-getmodulehandle-510041809-92e59481-49dc-4f6c-bc6d-74133ba5fa3b.png"/></a></figure><h3 id="9b5f1e9b-b06b-4758-8261-317165478f3e" class=""><strong>Case Sensitive DLL Names</strong></h3><p id="adaa0567-87e4-4cae-95ab-bde40737fd10" class="">By examining the output in the previous image, one can easily observe that some DLL names are capitalized and others are not, which affects the ability to obtain the DLL base address (<code>HMODULE</code>). For example, if one is searching for the <code>KERNEL32.DLL</code> DLL and passes <code>Kernel32.DLL</code> instead, the <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strcmp-wcscmp-mbscmp?view=msvc-170">wcscmp</a> function will treat both as different strings.</p><p id="8c434cd1-4432-4a26-ba76-6ceb4a465bd6" class="">To address this, the helper function <code>IsStringEqual</code> was created to take two strings and convert them into a lower-case representation, then compare them in this state. It returns true if both strings are equal and false otherwise.</p><pre id="c5800b93-be8f-46f3-82c4-b3319defcf5d" class="code code-wrap"><code>
BOOL IsStringEqual (IN LPCWSTR Str1, IN LPCWSTR Str2) {

	WCHAR   lStr1	[MAX_PATH],
			lStr2	[MAX_PATH];

	int		len1	= lstrlenW(Str1),
			len2	= lstrlenW(Str2);

	int		i		= 0,
			j		= 0;

	// Checking length. We dont want to overflow the buffers
	if (len1 &gt;= MAX_PATH || len2 &gt;= MAX_PATH)
		return FALSE;

    // Converting Str1 to lower case string (lStr1)
	for (i = 0; i &lt; len1; i++){
		lStr1[i] = (WCHAR)tolower(Str1[i]);
	}
	lStr1[i++] = L&#x27;\0&#x27;; // null terminating

    // Converting Str2 to lower case string (lStr2)
	for (j = 0; j &lt; len2; j++) {
		lStr2[j] = (WCHAR)tolower(Str2[j]);
	}
	lStr2[j++] = L&#x27;\0&#x27;; // null terminating

	// Comparing the lower-case strings
	if (lstrcmpiW(lStr1, lStr2) == 0)
		return TRUE;

	return FALSE;
}

</code></pre><h3 id="ee4da28a-ae02-4921-a868-94e5bdb32d97" class=""><strong>DLL Base Address</strong></h3><p id="a3da24f4-6d1b-4ea8-8e12-8fde6421f718" class="">Obtaining the DLL base address requires referencing the <code>LDR_DATA_TABLE_ENTRY</code> structure. Unfortunately, large chunks of the structure are missing in Microsoft&#x27;s official documentation. Therefore, to gain a better understanding of the structure, a search was conducted on <a href="https://www.nirsoft.net/kernel_struct/vista/index.html">Windows Vista Kernel Structures</a>. The results for the structure can be found <a href="https://www.nirsoft.net/kernel_struct/vista/LDR_DATA_TABLE_ENTRY.html">here</a>.</p><pre id="401fcaa9-6358-4e1c-a77c-986d32775efd" class="code code-wrap"><code>typedef struct _LDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    WORD LoadCount;
    WORD TlsIndex;
    union {
        LIST_ENTRY HashLinks;
        struct {
            PVOID SectionPointer;
            ULONG CheckSum;
        };
    };
    union {
        ULONG TimeDateStamp;
        PVOID LoadedImports;
    };
    PACTIVATION_CONTEXT EntryPointActivationContext;
    PVOID PatchInformation;
    LIST_ENTRY ForwarderLinks;
    LIST_ENTRY ServiceTagLinks;
    LIST_ENTRY StaticLinks;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;
</code></pre><p id="b6dfdf3b-de4f-43f2-9a59-14c8d424e70e" class="">The DLL base address is <code>InInitializationOrderLinks.Flink</code>, although the name does not suggest that, but unfortunately Microsoft likes to confuse people. By comparing this member to Microsoft&#x27;s official documentation of <code>LDR_DATA_TABLE_ENTRY</code>, it can be seen that the base address of the DLL is a reserved element (<code>Reserved2[0]</code>).</p><p id="9d4f8cde-7b6c-4484-b210-9707705763df" class="">With this in mind, the <code>GetModuleHandle</code> replacement function can be completed.</p><h3 id="0e736855-a62f-4e9a-8b65-a25bd2f1dc38" class=""><strong>GetModuleHandle Replacement Function</strong></h3><p id="5e072251-b5b8-4a91-a18b-1cbca58807d8" class=""><code>GetModuleHandleReplacement</code> is the function that replaces <code>GetModuleHandle</code>. It will search for the given DLL name and if it&#x27;s loaded by the process it returns a handle to the DLL.</p><pre id="84603fcd-c7c2-47f8-9c8e-07ae87126e01" class="code code-wrap"><code>HMODULE GetModuleHandleReplacement(IN LPCWSTR szModuleName) {

// Getting PEB
#ifdef _WIN64 // if compiling as x64
	PPEB					pPeb		= (PEB*)(__readgsqword(0x60));
#elif _WIN32 // if compiling as x32
	PPEB					pPeb		= (PEB*)(__readfsdword(0x30));
#endif// Getting Ldr
	PPEB_LDR_DATA			pLdr		= (PPEB_LDR_DATA)(pPeb-&gt;Ldr);
	// Getting the first element in the linked list (contains information about the first module)
	PLDR_DATA_TABLE_ENTRY	pDte		= (PLDR_DATA_TABLE_ENTRY)(pLdr-&gt;InMemoryOrderModuleList.Flink);

	while (pDte) {

		// If not null
		if (pDte-&gt;FullDllName.Length != NULL) {

			// Check if both equal
			if (IsStringEqual(pDte-&gt;FullDllName.Buffer, szModuleName)) {
				wprintf(L&quot;[+] Found Dll \&quot;%s\&quot; \n&quot;, pDte-&gt;FullDllName.Buffer);
#ifdef STRUCTSreturn (HMODULE)(pDte-&gt;InInitializationOrderLinks.Flink);
#elsereturn (HMODULE)pDte-&gt;Reserved2[0];
#endif // STRUCTS}

			// wprintf(L&quot;[i] \&quot;%s\&quot; \n&quot;, pDte-&gt;FullDllName.Buffer);
		}
		else {
			break;
		}

		// Next element in the linked list
		pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);

	}

	return NULL;
}
</code></pre><p id="b3355e4f-3b4a-4935-8951-f8cd2c2b28c8" class="">One part of the code which was not explained is shown below. This part of the code determines whether Microsoft&#x27;s version of the <code>LDR_DATA_TABLE_ENTRY</code> structure is being used or the one from Windows Vista Kernel Structures. Depending on which one was used, the name of the member changes.</p><pre id="25c602aa-81c3-4247-bb77-8461646d44fe" class="code code-wrap"><code>#ifdef STRUCTSreturn (HMODULE)(pDte-&gt;InInitializationOrderLinks.Flink);
#elsereturn (HMODULE)pDte-&gt;Reserved2[0];
#endif // STRUCTS</code></pre><h3 id="e46df81c-ed1b-4a49-82f4-eb2113ee82ea" class=""><strong>GetModuleHandleReplacement2</strong></h3><p id="6cd42ab2-98d2-4d13-9d56-2e956728a5a0" class="">Another implementation of the <code>GetModuleHandleReplacement</code> function can be found in this module&#x27;s code. <code>GetModuleHandleReplacement2</code> performs DLL enumeration using the head and the linked list&#x27;s elements which utilize the doubly linked list concept. This function was created for users that are familiar with linked lists.</p><h3 id="3b7daee4-3367-4ede-b60a-5344d15fd138" class=""><strong>Demo</strong></h3><figure id="94c0965c-7677-41b3-8389-ce08e0ddee32" class="image"><a href="54%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetModuleHand%20031d95fe35cc41edac2064756d73a043/custom-getmodulehandle-610043506-5d864abe-3528-4e13-bf28-faeba07c12e2.png"><img style="width:1108px" src="54%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetModuleHand%20031d95fe35cc41edac2064756d73a043/custom-getmodulehandle-610043506-5d864abe-3528-4e13-bf28-faeba07c12e2.png"/></a></figure></div></article></body></html>