<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>18. Payload Encryption - RC4</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="ff80fad2-bcc7-4e79-8b27-0bb1fddd1be2" class="page sans"><header><h1 class="page-title"><a href="https://maldevacademy.com/modules/18"><strong>18. Payload Encryption - RC4</strong></a></h1></header><div class="page-body"><h2 id="f150d77b-55f2-467c-a5f4-dd52749633f4" class=""><strong>Payload Encryption - RC4</strong></h2><h3 id="b7117010-2cb0-48f2-8e30-44711a580b5b" class=""><strong>Introduction</strong></h3><p id="0cb89683-081f-4a02-88c8-3874679f27ab" class="">RC4 is a fast and efficient stream cipher that is also a bidirectional encryption algorithm that allows the same function to be used for both encryption and decryption. There are several C implementations of RC4 publicly available but this module will demonstrate three ways of performing RC4 encryption.</p><p id="eb3fe75d-339d-4372-af92-cc9c5513d680" class="">Note that diving into how the RC4 algorithm works is not the goal of this module and it&#x27;s not required to fully understand it in depth. Rather the goal is encrypting the payload to evade detection.</p><h3 id="b5535357-07a6-486d-a892-4c910ede328f" class=""><strong>RC4 Encryption - Method 1</strong></h3><p id="c0ad8581-68fe-4f66-9e1f-672791235530" class="">This method uses the RC4 implementation found <a href="https://www.oryx-embedded.com/doc/rc4_8c_source.html">here</a> due to its stability and well-written code. There are two functions <code>rc4Init</code> and <code>rc4Cipher</code> which are used to initialize a <code>rc4context</code> structure and perform the RC4 encryption, respectively.</p><pre id="9adaee87-ce7c-4686-92af-d0dfdce7176f" class="code code-wrap"><code>typedef struct
{
	unsigned int i;
	unsigned int j;
	unsigned char s[256];

} Rc4Context;


void rc4Init(Rc4Context* context, const unsigned char* key, size_t length)
{
	unsigned int i;
	unsigned int j;
	unsigned char temp;

	// Check parameters
	if (context == NULL || key == NULL)
		return ERROR_INVALID_PARAMETER;

	// Clear context
	context-&gt;i = 0;
	context-&gt;j = 0;

	// Initialize the S array with identity permutation
	for (i = 0; i &lt; 256; i++)
	{
		context-&gt;s[i] = i;
	}

	// S is then processed for 256 iterations
	for (i = 0, j = 0; i &lt; 256; i++)
	{
		//Randomize the permutations using the supplied key
		j = (j + context-&gt;s[i] + key[i % length]) % 256;

		//Swap the values of S[i] and S[j]
		temp = context-&gt;s[i];
		context-&gt;s[i] = context-&gt;s[j];
		context-&gt;s[j] = temp;
	}

}


void rc4Cipher(Rc4Context* context, const unsigned char* input, unsigned char* output, size_t length){
	unsigned char temp;

	// Restore context
	unsigned int i = context-&gt;i;
	unsigned int j = context-&gt;j;
	unsigned char* s = context-&gt;s;

	// Encryption loop
	while (length &gt; 0)
	{
		// Adjust indices
		i = (i + 1) % 256;
		j = (j + s[i]) % 256;

		// Swap the values of S[i] and S[j]
		temp = s[i];
		s[i] = s[j];
		s[j] = temp;

		// Valid input and output?
		if (input != NULL &amp;&amp; output != NULL)
		{
			//XOR the input data with the RC4 stream
			*output = *input ^ s[(s[i] + s[j]) % 256];

			//Increment data pointers
			input++;
			output++;
		}

		// Remaining bytes to process
		length--;
	}

	// Save context
	context-&gt;i = i;
	context-&gt;j = j;
}

</code></pre><h3 id="f7136683-06f8-4eaf-ab83-6ff7545de4f4" class=""><strong>RC4 Encryption</strong></h3><p id="bc83bb64-30a8-4d0a-8561-2c5521d4cf8b" class="">The code below shows how the <code>rc4Init</code> and <code>rc4Cipher</code> functions are used to encrypt a payload.</p><pre id="af82e0f4-adeb-4829-8003-1b1fd3411dfc" class="code code-wrap"><code>	// Initialization
	Rc4Context ctx = { 0 };

	// Key used for encryption
	unsigned char* key = &quot;maldev123&quot;;
	rc4Init(&amp;ctx, key, sizeof(key));

	// Encryption //
	// plaintext - The payload to be encrypted
	// ciphertext - A buffer that is used to store the outputted encrypted data
	rc4Cipher(&amp;ctx, plaintext, ciphertext, sizeof(plaintext));
</code></pre><h3 id="78cf4cb9-7163-42c4-8b51-d1e52ebe02b1" class=""><strong>RC4 Decryption</strong></h3><p id="bfc0f0b1-9ee2-4b54-ae23-6b5d3465586d" class="">The code below shows how the <code>rc4Init</code> and <code>rc4Cipher</code> functions are used to decrypt a payload.</p><pre id="96721619-fe9a-4228-9752-d57c4c2f8650" class="code code-wrap"><code>	// Initialization
	Rc4Context ctx = { 0 };

	// Key used to decrypt
	unsigned char* key = &quot;maldev123&quot;;
	rc4Init(&amp;ctx, key, sizeof(key));

	// Decryption //
	// ciphertext - Encrypted payload to be decrypted
	// plaintext - A buffer that is used to store the outputted plaintext data
	rc4Cipher(&amp;ctx, ciphertext, plaintext, sizeof(ciphertext));
</code></pre><h3 id="a1509a46-0b83-490a-91f4-ea816b5a1e79" class=""><strong>RC4 Encryption - Method 2</strong></h3><p id="e15b44c1-2b02-4c86-9c89-59935c4779a2" class="">The undocumented Windows NTAPI <code>SystemFunction032</code> offers a faster and smaller implementation of the RC4 algorithm. Additional information about this API can be found on <a href="https://source.winehq.org/WineAPI/SystemFunction032.html">this Wine API page</a>.</p><h3 id="f26760fe-4fb9-4f1b-b349-99ac13a888d9" class=""><strong>SystemFunction032</strong></h3><p id="a606ef56-11cb-4501-87be-a8afbe80a53d" class="">The documentation page states that the function <code>SystemFunction032</code> accepts two parameters of type <code>USTRING</code>.</p><pre id="51075ba3-4a3e-4f2c-80d3-a3bbc39122a8" class="code code-wrap"><code> NTSTATUS SystemFunction032
 (
  struct ustring*       data,
  const struct ustring* key
 )
</code></pre><h3 id="11b0cb70-15f8-4f29-b507-94e989ee2f5f" class=""><strong>USTRING Structure</strong></h3><p id="a5f7ec0b-9072-43be-9aed-b1bfa84b20f7" class="">Unfortunately, since this is an undocumented API the structure of <code>USTRING</code> is unknown. But through additional research, it&#x27;s possible to locate the <code>USTRING</code> structure definition in <a href="https://github.com/wine-mirror/wine/blob/master/dlls/advapi32/crypt.h#L94">wine/crypt.h</a>. The structure is shown below.</p><pre id="3f24c14e-e5eb-46df-9c2a-2572681e948f" class="code code-wrap"><code>typedef struct
{
	DWORD	Length;         // Size of the data to encrypt/decrypt
	DWORD	MaximumLength;  // Max size of the data to encrypt/decrypt, although often its the same as Length (USTRING.Length = USTRING.MaximumLength = X)
	PVOID	Buffer;         // The base address of the data to encrypt/decrypt

} USTRING;
</code></pre><p id="a61909e8-284f-4fe2-9b7b-38884a922cdc" class="">Now that the <code>USTRING</code> struct is known, the <code>SystemFunction032</code> function can be used.</p><h3 id="b9948c49-fd8b-49d5-b55c-b9c9e500e3e7" class=""><strong>Retrieving SystemFunction032&#x27;s Address</strong></h3><p id="c1465c8f-4b79-4d5a-afce-d8aeba13b09d" class="">To use <code>SystemFunction032</code>, its address must first be retrieved. Since <code>SystemFunction032</code> is exported from <code>advapi32.dll</code>, the DLL must be loaded into the process using <code>LoadLibrary</code>. The return value of the function call can be used directly in <code>GetProcAddress</code>.</p><p id="a052d857-7f95-4c0d-9865-49254bb0daf5" class="">Once the address of <code>SystemFunction032</code> has been successfully retrieved, it should be type-casted to a function pointer matching the definition found on the previously referenced <a href="https://source.winehq.org/WineAPI/SystemFunction032.html">Wine API page</a>. However, the returned address can be casted directly from <code>GetProcAddress</code>. This is all demonstrated in the snippet below.</p><pre id="fb13b449-5130-474e-a8d1-8863fcc494b1" class="code code-wrap"><code>fnSystemFunction032 SystemFunction032 = (fnSystemFunction032) GetProcAddress(LoadLibraryA(&quot;Advapi32&quot;), &quot;SystemFunction032&quot;);
</code></pre><p id="23b941c0-c5c4-4276-8596-a5d434fe877e" class="">The function pointer of <code>SystemFunction032</code> is defined as the <code>fnSystemFunction032</code> data type which is shown below.</p><pre id="1f148deb-1fe3-42c0-bb9a-b0b971a1022a" class="code code-wrap"><code>typedef NTSTATUS(NTAPI* fnSystemFunction032)(
	struct USTRING* Data,   // Structure of type USTRING that holds information about the buffer to encrypt / decrypt
	struct USTRING* Key     // Structure of type USTRING that holds information about the key used while encryption / decryption
);
</code></pre><h3 id="c258c039-bfab-4099-bf38-c38cafa7860e" class=""><strong>SystemFunction032 Usage</strong></h3><p id="73bd792a-7579-4d42-ace8-26af36de209f" class="">The snippet below provides a working code sample that utilizes the <code>SystemFunction032</code> function to perform RC4 encryption and decryption.</p><pre id="0033d913-5071-4d46-9ebf-afb6af32aae3" class="code code-wrap"><code>typedef struct
{
	DWORD	Length;
	DWORD	MaximumLength;
	PVOID	Buffer;

} USTRING;

typedef NTSTATUS(NTAPI* fnSystemFunction032)(
	struct USTRING* Data,
	struct USTRING* Key
);

/*
Helper function that calls SystemFunction032
* pRc4Key - The RC4 key use to encrypt/decrypt
* pPayloadData - The base address of the buffer to encrypt/decrypt
* dwRc4KeySize - Size of pRc4key (Param 1)
* sPayloadSize - Size of pPayloadData (Param 2)
*/
BOOL Rc4EncryptionViaSystemFunc032(IN PBYTE pRc4Key, IN PBYTE pPayloadData, IN DWORD dwRc4KeySize, IN DWORD sPayloadSize) {

	NTSTATUS STATUS	= NULL;

	USTRING Data = {
		.Buffer         = pPayloadData,
		.Length         = sPayloadSize,
		.MaximumLength  = sPayloadSize
	};

	USTRING	Key = {
		.Buffer         = pRc4Key,
		.Length         = dwRc4KeySize,
		.MaximumLength  = dwRc4KeySize
	},

	fnSystemFunction032 SystemFunction032 = (fnSystemFunction032)GetProcAddress(LoadLibraryA(&quot;Advapi32&quot;), &quot;SystemFunction032&quot;);

	if ((STATUS = SystemFunction032(&amp;Data, &amp;Key)) != 0x0) {
		printf(&quot;[!] SystemFunction032 FAILED With Error: 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	return TRUE;
}
</code></pre><h3 id="1d0b0123-ba09-4b0f-9298-7d89f2f6e629" class=""><strong>RC4 Encryption - Method 3</strong></h3><p id="a2c53b5d-bf2b-46ab-bd74-bf85a30017b2" class="">Another way to implement the RC4 algorithm is using the <code>SystemFunction033</code> which takes the same parameters as the previously shown <code>SystemFunction032</code> function.</p><pre id="7c9376d5-e1fa-4b32-98b4-51e866fbd00e" class="code code-wrap"><code>typedef struct
{
	DWORD	Length;
	DWORD	MaximumLength;
	PVOID	Buffer;

} USTRING;


typedef NTSTATUS(NTAPI* fnSystemFunction033)(
	struct USTRING* Data,
	struct USTRING* Key
	);


/*
Helper function that calls SystemFunction033
* pRc4Key - The RC4 key use to encrypt/decrypt
* pPayloadData - The base address of the buffer to encrypt/decrypt
* dwRc4KeySize - Size of pRc4key (Param 1)
* sPayloadSize - Size of pPayloadData (Param 2)
*/
BOOL Rc4EncryptionViSystemFunc033(IN PBYTE pRc4Key, IN PBYTE pPayloadData, IN DWORD dwRc4KeySize, IN DWORD sPayloadSize) {

	NTSTATUS	STATUS = NULL;

	USTRING		Key = {
			.Buffer        = pRc4Key,
			.Length        = dwRc4KeySize,
			.MaximumLength = dwRc4KeySize
	};

	USTRING 	Data = {
			.Buffer         = pPayloadData,
			.Length         = sPayloadSize,
			.MaximumLength  = sPayloadSize
	};

	fnSystemFunction033 SystemFunction033 = (fnSystemFunction033)GetProcAddress(LoadLibraryA(&quot;Advapi32&quot;), &quot;SystemFunction033&quot;);

	if ((STATUS = SystemFunction033(&amp;Data, &amp;Key)) != 0x0) {
		printf(&quot;[!] SystemFunction033 FAILED With Error: 0x%0.8X \n&quot;, STATUS);
		return FALSE;
	}

	return TRUE;
}

</code></pre><h3 id="fe27d1cc-48ce-4222-abce-071a313ebce9" class=""><strong>Encryption/Decryption Key Format</strong></h3><p id="bdd3e29e-7d7a-494e-a196-6ec43755c68a" class="">The code snippets in this module and other encryption modules use one valid way of representing the encryption/decryption key. However, it&#x27;s important to be aware that the key can be represented using several different ways.</p><p id="15b6bb8c-b1b9-4ca6-8317-2410fdc8aa04" class="">Be aware that hardcoding the plaintext key into the binary is considered bad practice and can be easily pulled when the malware is analyzed. Future modules will provide solutions to ensure the key cannot be easily retrieved.</p><pre id="1620285e-6c91-4f18-aca6-c5a724e1e2b1" class="code code-wrap"><code>// Method 1
unsigned char* key = &quot;maldev123&quot;;

// Method 2
// This is &#x27;maldev123&#x27; represented as an array of hexadecimal bytes
unsigned char key[] = {
	0x6D, 0x61, 0x6C, 0x64, 0x65, 0x76, 0x31, 0x32, 0x33
};

// Method 3
// This is &#x27;maldev123&#x27; represented in a hex/string form (hexadecimal escape sequence)
unsigned char* key = &quot;\x6D\x61\x64\x65\x76\x31\x32\x33&quot;;

// Method 4 - better approach (via stack strings)
// This is &#x27;maldev123&#x27; represented in an array of chars
unsigned char key[] = {
	&#x27;m&#x27;, &#x27;a&#x27;, &#x27;l&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;v&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;
};</code></pre></div></article></body></html>