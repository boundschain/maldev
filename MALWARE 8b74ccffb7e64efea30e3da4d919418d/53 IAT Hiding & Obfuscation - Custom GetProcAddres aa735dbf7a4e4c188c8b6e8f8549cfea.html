<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>53. IAT Hiding &amp; Obfuscation - Custom GetProcAddress</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="aa735dbf-7a4e-4c18-8c8b-6e8f8549cfea" class="page sans"><header><h1 class="page-title"><a href="https://maldevacademy.com/modules/53"><strong>53. IAT Hiding &amp; Obfuscation - Custom GetProcAddress</strong></a></h1></header><div class="page-body"><h2 id="c3077bea-ddf2-40fe-a9e3-60151089013b" class=""><strong>IAT Hiding &amp; Obfuscation - Custom GetProcAddress</strong></h2><h3 id="28ea1f7c-27e7-4e9e-b629-1a366091d5f6" class=""><strong>Introduction</strong></h3><p id="df35a23d-e8df-40db-976f-746b7b0a3239" class="">The <code>GetProcAddress</code> WinAPI retrieves the address of an exported function from a specified module handle. The function returns <code>NULL</code> if the function name is not found in the specified module handle.</p><p id="2a0b872a-c2e8-483d-a793-2b28dbe7dfcd" class="">In this module, a function that replaces <code>GetProcAddress</code> will be implemented. The new function&#x27;s prototype is shown below.</p><pre id="6121d8d4-ed1a-4ea9-9ae7-35262689d3a5" class="code code-wrap"><code>FARPROC GetProcAddressReplacement(IN HMODULE hModule, IN LPCSTR lpApiName) {}
</code></pre><h3 id="b9a2f438-3bea-4514-b86f-d371eb8c0b2e" class=""><strong>How GetProcAddress Works</strong></h3><p id="72b66a95-08de-4f02-9341-6748f7a73cdb" class="">The first point that must be addressed is how a function&#x27;s address is found and retrieved by the <code>GetProcAddress</code> WinAPI.</p><p id="f039eb01-5b28-4c8d-b427-74e6abc96d9e" class="">The <code>hModule</code> parameter is the base address of the loaded DLL. This is the address where the DLL module is found in the address space of the process. With that in mind, retrieving a function&#x27;s address is found by looping through the exported functions inside the provided DLL and checking if the target function&#x27;s name exists. If there&#x27;s a valid match, retrieve the address.</p><p id="c375a132-f63a-43fd-9071-fde6d126f02d" class="">To access the exported functions, it&#x27;s necessary to access the DLL&#x27;s export table and loop through it in search of the target function name.</p><h3 id="bac83e46-84c1-4d86-b359-6932d1b4f608" class=""><strong>Recall - Export Table Structure</strong></h3><p id="120c5bf1-0e8b-498f-94db-1ae6715635d7" class="">Recall the <em>Parsing PE Headers</em> module, it was mentioned that the export table is a structure defined as <code>IMAGE_EXPORT_DIRECTORY</code>.</p><pre id="4bf0aa72-f1be-4313-9064-01cbff230a14" class="code code-wrap"><code>typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    DWORD   AddressOfFunctions;     // RVA from base of image
    DWORD   AddressOfNames;         // RVA from base of image
    DWORD   AddressOfNameOrdinals;  // RVA from base of image
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
</code></pre><p id="4b63bf86-dae1-4862-a651-c8131ab98131" class="">The relevant members of this structure for this module are the last three.</p><ul id="674bf09f-76fe-44d0-8dea-6ec591513f6f" class="bulleted-list"><li style="list-style-type:disc"><code>AddressOfFunctions</code> - Specifies the address of an array of addresses of the exported functions.</li></ul><ul id="2b8857d1-605c-496d-9602-9b1bbcab2eeb" class="bulleted-list"><li style="list-style-type:disc"><code>AddressOfNames</code> - Specifies the address of an array of addresses of the names of the exported functions.</li></ul><ul id="3761bb9a-01da-4e10-8c08-8723e3cdd6ca" class="bulleted-list"><li style="list-style-type:disc"><code>AddressOfNameOrdinals</code> - Specifies the address of an array of <em>ordinal numbers</em> for the exported functions.</li></ul><h3 id="3ff8ac0d-3b33-40ec-a05f-57be3b881afd" class=""><strong>Recall - Accessing the Export Table</strong></h3><p id="0b1bbdec-dd97-40bc-8549-be5d7e1b4b6d" class="">Let&#x27;s recall how to retrieve the export directory, <code>IMAGE_EXPORT_DIRECTORY</code>. The code snippet below should be familiar since it was explained in the <em>Parsing PE Headers</em> module.</p><p id="ccad410a-f55a-4056-b82c-8674661e8d4a" class="">The <code>pBase</code> variable at the beginning of the function is the only new addition in the code snippet. This variable is created to avoid type-casting later on when converting relative virtual addresses (RVAs) to virtual addresses (VAs). The Visual Studio compiler will throw an error when adding a <code>PVOID</code> data type to a value, and therefore <code>hModule</code> was casted to <code>PBYTE</code> instead.</p><pre id="04da33cc-a6e1-46ea-aa77-8a9666316383" class="code code-wrap"><code>FARPROC GetProcAddressReplacement(IN HMODULE hModule, IN LPCSTR lpApiName) {

	// We do this to avoid casting each time we use &#x27;hModule&#x27;
	PBYTE pBase = (PBYTE) hModule;

	// Getting the DOS header and performing a signature check
	PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;
	if (pImgDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)
		return NULL;

	// Getting the NT headers and performing a signature check
	PIMAGE_NT_HEADERS	pImgNtHdrs	= (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-&gt;e_lfanew);
	if (pImgNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE)
		return NULL;

	// Getting the optional header
	IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-&gt;OptionalHeader;

	// Getting the image export table
	// This is the export directory
	PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY) (pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    // ...
}
</code></pre><h3 id="f3b171a0-1e94-4cce-bbba-1f07aa197c63" class=""><strong>Accessing Exported Functions</strong></h3><p id="0ee66cad-515d-4cfe-8d75-92bf6f3504b4" class="">After obtaining a pointer to the <code>IMAGE_EXPORT_DIRECTORY</code> structure, it&#x27;s possible to loop through the exported functions. The <code>NumberOfFunctions</code> member specifies the number of functions exported by <code>hModule</code>. As a result, the maximum iterations of the loop should be equivalent to <code>NumberOfFunctions</code>.</p><pre id="f647dccc-022d-4e59-ab93-08bd8149dbd7" class="code code-wrap"><code>for (DWORD i = 0; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++){
  // Searching for the target exported function
}
</code></pre><h3 id="c5da82d4-f64b-47d4-ae3b-e5c781ad277c" class=""><strong>Building The Search Logic</strong></h3><p id="30070706-f535-47b7-b8dd-83834ccfa3da" class="">The next step is to build the search logic for the functions. The building of the search logic requires the use of <code>AddressOfFunctions</code>, <code>AddressOfNames</code>, and <code>AddressOfNameOrdinals</code>, which are all arrays containing RVAs referencing a single unique function in the export table.</p><pre id="d09502f6-4ca6-41db-a4fe-f5e9a318cb9b" class="code code-wrap"><code>typedef struct _IMAGE_EXPORT_DIRECTORY {
    // ...
	// ...
    DWORD   AddressOfFunctions;     // RVA from base of image
    DWORD   AddressOfNames;         // RVA from base of image
    DWORD   AddressOfNameOrdinals;  // RVA from base of image
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
</code></pre><p id="89aafbc5-65a3-4b3f-a992-aed51f9573c5" class="">Since these elements are RVAs, the base address of the module, <code>pBase</code>, must be added to get the VA. The first two code snippets should be straightforward. They retrieve the function&#x27;s name and the function&#x27;s address, respectively. The third snippet retrieves the function&#x27;s <em>ordinal</em>, which is explained in detail in the next section.</p><pre id="d818bd30-ace5-42fc-9722-c48206e67e8f" class="code code-wrap"><code>// Getting the function&#x27;s names array pointer
PDWORD FunctionNameArray 	= (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);

// Getting the function&#x27;s addresses array pointer
PDWORD FunctionAddressArray 	= (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);

// Getting the function&#x27;s ordinal array pointer
PWORD  FunctionOrdinalArray 	= (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);
</code></pre><h3 id="0aaa00aa-2744-4d2b-9237-6bc5bc9f3194" class=""><strong>Understanding Ordinals</strong></h3><p id="42bfb06a-a130-4c08-92b7-4dc466e97fa8" class="">An ordinal of a function is an integer value that represents the position of the function within an exported function table in the DLL. The export table is organized as a list (array) of function pointers, with each function being assigned an ordinal value based on its position in the table.</p><figure id="2a44082d-7ed8-44f6-86cc-d1d8e82cc6cc" class="image"><a href="53%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetProcAddres%20aa735dbf7a4e4c188c8b6e8f8549cfea/ordinals-getproc.png"><img style="width:476px" src="53%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetProcAddres%20aa735dbf7a4e4c188c8b6e8f8549cfea/ordinals-getproc.png"/></a></figure><p id="bcb6a27d-a7dc-417e-96ae-2eb53acf22bb" class="">It&#x27;s important to note that the ordinal value is used to identify a function&#x27;s <strong>address</strong> rather than its name. The export table operates this way to handle cases where the function name is not available or is not unique. In addition to that, fetching a function&#x27;s address using its ordinal is faster than using its name. For this reason, the operating system uses the ordinal to retrieve a function&#x27;s address.</p><p id="52377d4c-6f82-47f4-a8f6-6bee11c969b0" class="">For example, <code>VirtualAlloc</code>&#x27;s address is equal to <code>FunctionAddressArray[ordinal of VirtualAlloc]</code>, where <code>FunctionAddressArray</code> is the function&#x27;s addresses array pointer fetched from the export table.</p><p id="92825cfd-4d98-4b13-b845-3321beed0805" class="">With this in mind, the following code snippet will print the ordinal value of each function in the function array of a specified module.</p><pre id="3ea6b2de-0aa2-496d-8d6b-cd0c1641b792" class="code code-wrap"><code>// Getting the function&#x27;s names array pointer
PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);

// Getting the function&#x27;s addresses array pointer
PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);

// Getting the function&#x27;s ordinal array pointer
PWORD  FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);

// Looping through all the exported functions
for (DWORD i = 0; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++){

	// Getting the name of the function
	CHAR* pFunctionName		= (CHAR*)(pBase + FunctionNameArray[i]);

	// Getting the ordinal of the function
	WORD wFunctionOrdinal = FunctionOrdinalArray[i];

	// Printing
	printf(&quot;[ %0.4d ] NAME: %s -\t ORDINAL: %d\n&quot;, i, pFunctionName, wFunctionOrdinal);
}
</code></pre><h3 id="41f3e73c-563c-4098-b132-a14598e3bb60" class=""><strong>GetProcAddressReplacement Partial Demo</strong></h3><p id="62bdeae6-ecae-4d89-8d26-6a83c2d4d289" class="">Although <code>GetProcAddressReplacement</code> is not complete yet, it should now output the function names and their associated ordinal numbers. To test out what&#x27;s been built so far, call the function with the following parameters:</p><pre id="56c5725d-2469-43e3-b591-c6c9b7f8741b" class="code code-wrap"><code>GetProcAddressReplacement(GetModuleHandleA(&quot;ntdll.dll&quot;), NULL);
</code></pre><p id="48afc23f-2b60-486e-b743-61bc8b37e6da" class="">As expected, the function name and the function&#x27;s ordinal are printed to the console.</p><figure id="91e9fb3d-0ce7-489e-b418-1d7079e81393" class="image"><a href="53%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetProcAddres%20aa735dbf7a4e4c188c8b6e8f8549cfea/custom-getproc-109913387-f0fdcc3d-e9aa-48f3-bb97-615758130bad.png"><img style="width:1014px" src="53%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetProcAddres%20aa735dbf7a4e4c188c8b6e8f8549cfea/custom-getproc-109913387-f0fdcc3d-e9aa-48f3-bb97-615758130bad.png"/></a></figure><h3 id="a356f710-02f5-4517-ac3e-09cf367666d3" class=""><strong>Ordinal To Address</strong></h3><p id="d62ed971-0e17-4fe1-b719-e28891529317" class="">With the function&#x27;s ordinal value, it&#x27;s possible to get the function&#x27;s address.</p><pre id="72d47ffb-f171-4ab8-b477-2b546867690b" class="code code-wrap"><code>// Getting the function&#x27;s names array pointer
PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);

// Getting the function&#x27;s addresses array pointer
PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);

// Getting the function&#x27;s ordinal array pointer
PWORD  FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);


// Looping through all the exported functions
for (DWORD i = 0; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++){

	// Getting the name of the function
	CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]);

	// Getting the ordinal of the function
	WORD wFunctionOrdinal = FunctionOrdinalArray[i];

	// Getting the address of the function through it&#x27;s ordinal
	PVOID pFunctionAddress = (PVOID)(pBase + FunctionAddressArray[wFunctionOrdinal]);

	printf(&quot;[ %0.4d ] NAME: %s -\t ADDRESS: 0x%p  -\t ORDINAL: %d\n&quot;, i, pFunctionName, pFunctionAddress, wFunctionOrdinal);
}
</code></pre><p id="94523d0f-77fe-45d8-8006-11176cf6c058" class="">To verify the functionality, open <code>notepad.exe</code> using xdbg and check the exports of <code>ntdll.dll</code>.</p><figure id="b0bf38e8-cbf7-40cf-8042-91674594b40f" class="image"><a href="53%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetProcAddres%20aa735dbf7a4e4c188c8b6e8f8549cfea/custom-getproc-209914072-4c8104f3-6208-42c4-8822-479c44d291ce.png"><img style="width:1682px" src="53%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetProcAddres%20aa735dbf7a4e4c188c8b6e8f8549cfea/custom-getproc-209914072-4c8104f3-6208-42c4-8822-479c44d291ce.png"/></a></figure><p id="d5014a99-a483-4e55-ae03-741a056d0f92" class="">The image above shows the address of <code>A_SHAUpdate</code> being <code>0x00007FFD384D2D10</code> in both xdbg and using the <code>GetProcAddressReplacement</code> function. Although notice that the ordinals are different for the function due to the Windows Loader generating a new array of ordinals for every process.</p><h3 id="3d89dbc0-240e-4a4a-a846-27018334d31b" class=""><strong>GetProcAddressReplacement Code</strong></h3><p id="0460b789-0efb-41e8-98ee-75cf1e4b2933" class="">The last bit of code needed for the function to be complete is a way to compare the exported function names to the target function name, <code>lpApiName</code>. This is easily done using <code>strcmp</code>. Then finally, return the function address when there is a match.</p><pre id="be29aa4f-24ea-449e-98db-84b250ff3108" class="code code-wrap"><code>FARPROC GetProcAddressReplacement(IN HMODULE hModule, IN LPCSTR lpApiName) {

	// We do this to avoid casting at each time we use &#x27;hModule&#x27;
	PBYTE pBase = (PBYTE)hModule;

	// Getting the dos header and doing a signature check
	PIMAGE_DOS_HEADER	pImgDosHdr		= (PIMAGE_DOS_HEADER)pBase;
	if (pImgDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)
		return NULL;

	// Getting the nt headers and doing a signature check
	PIMAGE_NT_HEADERS	pImgNtHdrs		= (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-&gt;e_lfanew);
	if (pImgNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE)
		return NULL;

	// Getting the optional header
	IMAGE_OPTIONAL_HEADER	ImgOptHdr	= pImgNtHdrs-&gt;OptionalHeader;

	// Getting the image export table
	PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY) (pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	// Getting the function&#x27;s names array pointer
	PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);

	// Getting the function&#x27;s addresses array pointer
	PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);

	// Getting the function&#x27;s ordinal array pointer
	PWORD  FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);


	// Looping through all the exported functions
	for (DWORD i = 0; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++){

		// Getting the name of the function
		CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]);

		// Getting the address of the function through its ordinal
		PVOID pFunctionAddress	= (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);

		// Searching for the function specified
		if (strcmp(lpApiName, pFunctionName) == 0){
			printf(&quot;[ %0.4d ] FOUND API -\t NAME: %s -\t ADDRESS: 0x%p  -\t ORDINAL: %d\n&quot;, i, pFunctionName, pFunctionAddress, FunctionOrdinalArray[i]);
			return pFunctionAddress;
		}
	}

	return NULL;
}
</code></pre><h3 id="46dcd2ef-61d4-4b23-b3ea-dfc71bc42a9b" class=""><strong>GetProcAddressReplacement Final Demo</strong></h3><p id="55c6fe76-4f68-4ff8-be12-273b7570e122" class="">The image below shows the output of both <code>GetProcAddress</code> and <code>GetProcAddressReplacement</code> searching for the address of <code>NtAllocateVirtualMemory</code>. As expected, both have resulted in the correct function address and therefore a custom implementation of <code>GetProcAddress</code> was successfully built.</p><figure id="9584c0ac-d42c-4450-b8de-24a4059a42e5" class="image"><a href="53%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetProcAddres%20aa735dbf7a4e4c188c8b6e8f8549cfea/custom-getproc-309915517-9f411b29-61c3-4104-9d05-7fa8977ddeca.png"><img style="width:818px" src="53%20IAT%20Hiding%20&amp;%20Obfuscation%20-%20Custom%20GetProcAddres%20aa735dbf7a4e4c188c8b6e8f8549cfea/custom-getproc-309915517-9f411b29-61c3-4104-9d05-7fa8977ddeca.png"/></a></figure><p id="0a51921d-cd28-4cff-b492-6ad1f91e1a25" class="">
</p></div></article></body></html>